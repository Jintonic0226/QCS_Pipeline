---
jupyter:
  kernelspec:
    display_name: R
    language: R
    name: ir
  language_info:
    codemirror_mode: r
    file_extension: .r
    mimetype: text/x-r-source
    name: R
    pygments_lexer: r
    version: 4.4.2
  nbformat: 4
  nbformat_minor: 5
editor_options: 
  markdown: 
    wrap: 72
---

::: {#introduction .cell .markdown}
## Pipeline #2: QCS + Tissue Evaluation and Correction

In this pipeline, you will evaluate your Quality Control Standard (QCS)
and artificially generated tissue homogenates. After evaluation, you can
correct the intra- and inter-batch effects observed. The same three
datasets (no normalization, TIC normalization, IS normalization) will be
evaluated first. After correction, three additional datasets will be
evaluated (Combat-corrected, WaveICA-corrected, NormAE-corrected).

To assess the variation of QCS across intra- and inter-day batches, you
will use the following methods:

-   **Relative Standard Deviation (RSD) Calculation:** Serves as a
    measure of the Coefficient of Variation (CV).
-   **Intensity Plot:** Visualizes the trend between peak intensities
    and the measurement order.
-   **Violin Plot:**Visualizes the distribution of peak intensities at
    different measurement orders.
-   **QCS PCA Plot:** Visualizes the clustering and similarity of QCS
    samples in a PCA plot.

To assess the variation of tissue features throughout intra - and
inter-day batches, you will use the following methods:

-   **Relative Standard Deviation (RSD) Calculation:** Serves as a
    measure of the Coefficient of Variation (CV)
-   **PCA plot:** Visualize the clustering and similarity of tissue
    samples in a PCA plot accordingly to its sample type.

You can also check README file to follow through the pipeline. You can
either press the run button or press **Shift + Enter** to run each cell

1.  [Packages to Download](#package_2)
2.  [Input](#input_2)
3.  [QCS Evaluation](#qcs_evaluation_2)
    1.  [QCS RSD](#qcs_rsd_2)
    2.  [QCS Intensity Plot](#qcs_intensity_2)
    3.  [QCS Violin Plot](#qcs_violin_2)
    4.  [PCA Plot](#pca_2)
    5.  [QCS PCA Plot (with Average distance)](#qcs_pca_2)
4.  [Tissue Evaluation](#tissue_evaluation_2)
    1.  [Tissue_RSD](#tissue_rsd_2)
    2.  [Tissue_PCA_Plot (Intra/Intergroup)](#tissue_pca_2)
5.  [Correction](#correction_2)
    1.  [Combat](#combat_2)
    2.  [WaveICA](#waveica_2)
    3.  [NormAE (requires running externally)](#normae_2)
    4.  [Correction_Results](#correction_results_2)
6.  [Comparison](#comparison_2)
    1.  [QCS_RSD_Overview](#qcs_rsd_overview_2)
    2.  [QCS_Intensity_Plot_Overview](#qcs_intensity_overview_2)
    3.  [QCS_Violin_Plot_Overview](#qcs_violin_overview_2)
    4.  [PCA Plot Overview](#pca_overview_2)
    5.  [QCS_PCA_Plot_Overview](#qcs_pca_overview_2)
    6.  [Tissue_RSD_Overview](#tissue_rsd_overview_2)
    7.  [Tissue_PCA_Plot_Overview](#tissue_pca_overview_2)
    8.  [Average Distance Overview (QCS, Euclidean, Intra,
        Intergroup)](#distance_overview_2)
7.  [Outputs](#outputs_2)
:::

::: {#packages .cell .markdown}
## Packages to Download {#package_2}
:::

::: {#packages1 .cell .r}
```{r}
# Checking for R version
version
```
:::

::: {#packages3 .cell .r}
```{r}
## Packages for RSD overview table ##
packages_RSD <- c("htmltools", "kableExtra", "IRdisplay")

## Packages for Violin plot ##
packages_violin <- c("ggplot2", "dplyr", "RColorBrewer", "gridExtra")

## Package for PCA plot ##
packages_PCA <- c("zoo", "ggrepel", "cowplot")

## Package for excel sheet creating ##
packages_excel <- c("openxlsx")

## Combine all package lists ##
all_packages <- c(packages_RSD, packages_violin, packages_PCA, packages_excel)

## Install packages if not installed ##
for (pkg in all_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

## Check if all packages are installed ##
if (all(sapply(all_packages, requireNamespace, quietly = TRUE))) {
  cat("\033[1mSuccessfully Downloaded Packages\033[0m\n")
} else {
  cat("Some packages were not successfully installed.\n")
}
```
:::

:::: {#input .cell .markdown}
## Input Information {#input_2}

::: {style="text-align: center;"}
<img src="Image/instruction.png" alt="Instruction Image" style="width:80%;"/>
:::

**Upload these files in input folder**

1)  **Data matrix for No normalization** (csv file obtained from SCiLs
    lab directly)
2)  **Data matrix for TIC normalization** (csv file obtained from SCiLs
    lab directly)
3)  **Batch info (csv file with batch information for sample
    construction)** (check the given example file called
    'batch_info_TIC' - must have "injection.order" and "batch" column)

**These will need to be changed in the cell below**

1)  **File path for above 3 files**
2)  **QCS Analytes mass-to-charge ratio (m/z) values** (ie: propranolol
    260.16, D7-propranolol 267.14) (if using VS code, input at the top
    bar)
3)  **Sample set (tissue sample names, check the example given)**
::::

::: {#input2 .cell .r}
```{r}
### Please edit the file path, file name ###
## Please change the line with ## ## 
no_normalization_data_2 <- read.csv("Input/119feature_T&QCS_BaseRemoval_noNorm.csv", ## change file path ##
                                  header = FALSE,
                                  check.name = FALSE,
                                  stringsAsFactors = FALSE)

TIC_normalization_data_2 <- read.csv("Input/119feature_T&QCS_BaseRemoval_TICNorm.csv", ## change file path ##
                                   header = FALSE,
                                   check.name = FALSE,
                                   stringsAsFactors = FALSE) 

QCS_mz_value_2 <- as.numeric(readline("Enter QCS (ie: Propranolol) m/z value: ")) ## ie: 260.186 ##

IS_mz_value_2 <- as.numeric(readline("Enter Internal Standard (ie: D7-propranolol) m/z value: ")) ## ie: 267.187 ##

batch_info_2 <- read.csv("Input/batch_info_TIC.csv", ## change file path ##
                       header = TRUE,
                       check.name = FALSE,
                       stringsAsFactors = FALSE) 

cat("\033[1mChange the sample_set accordingly to the Dataset!\033[0m\n")

sample_set_2 <- c("ChickenHeart", "ChickenLiver", "GoatLiver") ## change sample type names ##
```
:::

::: {#input3 .cell .r}
```{r}
# Check if "injection.order" column and "batch" column exists
if ("injection.order" %in% colnames(batch_info_2)) {
    cat("\033[1mColumn 'injection.order' exists\033[0m\n")
} else {
    cat("\033[1mColumn 'injection.order' does not exist. Please check/edit colname for batch_info\033[0m\n")
}

if ("batch" %in% colnames(batch_info_2)) {
    cat("\033[1mColumn 'batch' exists.\033[0m\n")
} else {
    cat("\033[1mColumn 'batch' does not exist. Please check/edit colname for batch_info\033[0m\n")
}
```
:::

::: {#input4 .cell .r}
```{r}
## Creating result, dataset, output folders ##

# Saves each result in the result folder
if (!dir.exists("Excel")) {
  dir.create("Excel")
}

# Saves each result in the dataset folder
if (!dir.exists("Dataset")) {
  dir.create("Dataset")
}

# Saves each result in the output folder
if (!dir.exists("Output")) {
  dir.create("Output")
}
```
:::

::: {#dataset .cell .markdown}
## Pre-processing Datasets {#preprocessing_1}

Here we will preprocess the given dataset into three separate datasets:
No normalization, TIC normalization, and IS normalization for further
analysis

-   **No normalization dataset** refers to the original dataset without
    any normalization applied.

-   **Total Ion Count (TIC) normalization dataset** is obtained by
    dividing peak abundance by the sum of all detected peaks.

-   **Internal Standard (IS) normalization dataset** is obtained by
    dividng peak abundance of propranolol by the abundance of its
    internal standard (propranolol-d7).

In this pipeline, no normalization dataset and TIC normalization dataset
are exported from SCiLS Lab MVS 2024b Premium 3D. IS normalization
dataset is calculated in the pipeline.
:::

::: {#no_norm .cell .markdown}
## No normalization dataset

```{r}
## No Normalization Dataset ##
# Read the CSV file
rawdata <- no_normalization_data_2
mz_header <- unlist(strsplit(as.character(rawdata[9, 1]), ";"))[1]
peak_header <- unlist(strsplit(as.character(rawdata[9, 1]), ";"))[5:length(unlist(strsplit(as.character(rawdata[9, 1]), ";")))]
peak <- unlist(strsplit(as.character(rawdata[10, 1]), ";"))[5:length(unlist(strsplit(as.character(rawdata[9, 1]), ";")))]

mz_data_list <- list()
peak_data_list <- list()
combined_batch_data_list <- list()

# Extract data into datalist
for (i in 10:nrow(rawdata)){
  mz <- unlist(strsplit(as.character(rawdata[[i, 1]]), ";"))[1]
  peak <- unlist(strsplit(as.character(rawdata[i, 1]), ";"))[5:length(unlist(strsplit(as.character(rawdata[9, 1]), ";")))]
  mz_data_list[[i - 9]] <- mz
  peak_data_list[[i - 9]] <- peak
  combined_batch_data <- c(mz, peak)
  combined_batch_data_list[[i - 9]] <- combined_batch_data
}

# Combine data into a data frame
combined_batch_data_df_2 <- as.data.frame(do.call(rbind, combined_batch_data_list), stringsAsFactors = FALSE)

# Set column names as mz 
colnames(combined_batch_data_df_2) <- c("mz", peak_header)

# make name column (will be same as mz column)
combined_batch_data_df_2$name <- combined_batch_data_df_2$mz 

# Set 'rt' column to a constant value
combined_batch_data_df_2$rt <- 666 # Assigning rt a random number

# Reorder columns again
combined_batch_data_df_2 <- combined_batch_data_df_2[, c("name", "mz", "rt", peak_header)]

# check if each sample set exist in columns
sample_set_exist <- logical(length(sample_set_2))

# Check if each sample set exists in any of the column names
for (i in seq_along(sample_set_2)) {
  sample_set_exist[i] <- any(grepl(sample_set_2[i], colnames(combined_batch_data_df_2)))
}

# Identify sample sets that do not exist in any column names
missing_sample_sets <- sample_set_2[!sample_set_exist]

if (length(missing_sample_sets) > 0) {
  message("Error: The following sample sets do not exist in any column names: ", paste(missing_sample_sets, collapse = ", ", "check your sample_set"))
} else {
  message("Successfully made formatted table. All sample sets exist in at least one column name.")
}

# Check if m/z values exist in rows
QCS_mz_exist <- any(combined_batch_data_df_2$mz == QCS_mz_value_2)
IS_mz_exist <- any(combined_batch_data_df_2$mz == IS_mz_value_2)

# Print messages based on existence
if (!QCS_mz_exist) {
  message("Error: The QCS m/z value ", QCS_mz_value_2, " does not exist in any row.")
} else {
  message("The QCS m/z value ", IS_mz_value_2, " exists in at least one row.")
}

if (!IS_mz_exist) {
  message("Error: The Internal Standard m/z value ", IS_mz_value_2, " does not exist in any row.")
} else {
  message("The Internal Standard m/z value ", IS_mz_value_2, " exists in at least one row.")
}

# uncomment to check if combined_batch_data_df looks correct and if sample names are correct
#print(combined_batch_data_df_2)
#print(colnames(combined_batch_data_df_2))
#print(rownames(combined_batch_data_df_2))

# making as a formatted csv file
write.csv(combined_batch_data_df_2,
          file = "Dataset/formatted_no_norm_batch_data.csv",
          row.names = FALSE)

## Make batch info combined dataframe ##
# dataframe with injection order, batch info, batch data
combined_batch_data_df_2_transposed <- as.data.frame(t(combined_batch_data_df_2[, -(1:3)]))
colnames(combined_batch_data_df_2_transposed) <- combined_batch_data_df_2[, 1]
combined_batch_info_data_2 <- cbind(batch_info_2[,-1], combined_batch_data_df_2_transposed) 

# making as a formatted csv file
write.csv(combined_batch_info_data_2,
          file = "Dataset/formatted_no_norm_combined_batch_data.csv",
          row.names = TRUE)

cat("\033[1mSuccessfully formmated no normalized datasets (check Dataset folder)\033[0m\n")
```
:::

::: {#tic_norm .cell .markdown}
## TIC normalization dataset

```{r}
## TIC Normalization Dataset ##
# Read the CSV file
rawdata <- TIC_normalization_data_2
mz_header <- unlist(strsplit(as.character(rawdata[9, 1]), ";"))[1]
peak_header <- unlist(strsplit(as.character(rawdata[9, 1]), ";"))[5:length(unlist(strsplit(as.character(rawdata[9, 1]), ";")))]
peak <- unlist(strsplit(as.character(rawdata[10, 1]), ";"))[5:length(unlist(strsplit(as.character(rawdata[9, 1]), ";")))]

mz_data_list <- list()
peak_data_list <- list()
combined_batch_data_list <- list()

# Extract data
for (i in 10:nrow(rawdata)){
  mz <- unlist(strsplit(as.character(rawdata[[i, 1]]), ";"))[1]
  peak <- unlist(strsplit(as.character(rawdata[i, 1]), ";"))[5:length(unlist(strsplit(as.character(rawdata[9, 1]), ";")))]
  mz_data_list[[i - 9]] <- mz
  peak_data_list[[i - 9]] <- peak
  combined_batch_data <- c(mz, peak)
  combined_batch_data_list[[i - 9]] <- combined_batch_data
}

# Combine data into a data frame
combined_batch_data_df_TIC_2 <- as.data.frame(do.call(rbind, combined_batch_data_list), stringsAsFactors = FALSE)

# Set column names
colnames(combined_batch_data_df_TIC_2) <- c("mz", peak_header)

# make name column
combined_batch_data_df_TIC_2$name <- combined_batch_data_df_TIC_2$mz  # Assign 'name' column which is same as mz column

# Set 'rt' column to a constant value
combined_batch_data_df_TIC_2$rt <- 666 # Assigning rt a random number

# Reorder columns again
combined_batch_data_df_TIC_2 <- combined_batch_data_df_TIC_2[, c("name", "mz", "rt", peak_header)]

# uncomment to check 
#print(combined_batch_data_df)
#print(colnames(combined_batch_data_df_TIC_2))

# making as a formatted csv file
write.csv(combined_batch_data_df_TIC_2,
          file = "Dataset/formatted_TIC_norm_batch_data.csv",
          row.names = FALSE)

## Make batch info combined dataframe ##
# dataframe with injection order, batch info, batch data
combined_batch_data_df_transposed_TIC <- as.data.frame(t(combined_batch_data_df_TIC_2[, -(1:3)]))
colnames(combined_batch_data_df_transposed_TIC) <- combined_batch_data_df_TIC_2[, 1]
combined_batch_info_data_TIC_2 <- cbind(batch_info_2[,-1], combined_batch_data_df_transposed_TIC)  

# making as a formatted csv file for batch info data
write.csv(combined_batch_info_data_TIC_2,
          file = "Dataset/formatted_TIC_norm_combined_batch_data.csv",
          row.names = TRUE)

cat("\033[1mSucessfully formatted TIC normalized datasets (check Dataset folder).\033[0m\n")
```
:::

::: {#is_norm .cell .markdown}
## IS normalization dataset

```{r}
# IS normalization on no normalized dataset # 
# extract tissue samples away function
extract_qcs_data <- function(dataset, sample_set) {
  pattern <- paste(sample_set, collapse = "|")
  
  # Extract tissue rows
  tissue_rows <- grep(pattern, rownames(dataset))
  
  # Subset dataframe to exclude tissue rows
  qcs_data <- dataset[-tissue_rows, , drop = FALSE]
  
  return(qcs_data)
}

# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_2, sample_set_2)
batch_info_columns <- qcs_batch_info_data[, 1:2, drop = FALSE]

# extract qcs data
# propranolol
QCS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == QCS_mz_value_2, drop = FALSE]
col_names <- rownames(QCS_peak_data)
QCS_data <- cbind(batch_info_columns, QCS_peak_data)

QCS_peak_data_trans <- as.data.frame(t(QCS_peak_data))
colnames(QCS_peak_data_trans) <- col_names 
QCS_peak_data_trans <- as.numeric(QCS_peak_data_trans)

# IS 
IS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == IS_mz_value_2, drop = FALSE]
col_names <- rownames(IS_peak_data)
IS_data <- cbind(batch_info_columns, IS_peak_data)

IS_peak_data_trans <- as.data.frame(t(IS_peak_data))
colnames(IS_peak_data_trans) <- col_names 
IS_peak_data_trans <- as.numeric(IS_peak_data_trans)

# IS normalization = propranolol / IS
ratio <- QCS_peak_data_trans / IS_peak_data_trans
ratio_df <- as.data.frame(ratio)
rownames(ratio_df) <- col_names
ratio_data <- cbind(batch_info_columns,ratio_df)

ratio_data_csv <- as.data.frame(t(ratio_data))
rownames(ratio_data_csv) <- colnames(ratio_data)
#print(ratio_data_app_csv) # uncomment to see the dataset 

# making as a formatted csv file
write.csv(ratio_data_csv,
          file = "Dataset/formatted_IS_norm_batch_data.csv",
          row.names = TRUE)

cat("\033[1mSucessfully formatted IS normalization dataset (check Dataset folder).\033[0m\n")
```
:::

::: {#RSD_calculation .cell .markdown}
## QCS Evaluation {#qcs_evaluation_2}
:::

::: {#RSD_calculation2 .cell .markdown}
## 1. QCS RSD {#1-qcs-rsd_2}

```{r}
## run these functions first ##
# 1: Function to extract tissue samples away function
extract_qcs_data <- function(dataset, sample_set) {
  pattern <- paste(sample_set, collapse = "|")
  
  # Extract tissue rows
  tissue_rows <- grep(pattern, rownames(dataset))
  
  # Subset dataframe to exclude tissue rows
  qcs_data <- dataset[-tissue_rows, , drop = FALSE]
  
  return(qcs_data)
}
# 2. Function to calculate RSD
calculate_rsd <- function(data) {
  sd_value <- sd(data)
  mean_value <- mean(data)
  rsd <- (sd_value / mean_value) * 100
  return(rsd)
}

# 3. Function to calculate rsd for each batch
calculate_batch_rsd <- function(data, mz_value) {
  # Convert mz_value to character
  mz_value <- as.character(mz_value)
  # Convert column to numeric
  data[[mz_value]] <- as.numeric(data[[mz_value]], na.rm = TRUE)
  # Calculate RSD for each batch, rounding to two decimal places
  batch_rsd <- aggregate(data[[mz_value]],
                         by = list(batch = data$batch),
                         FUN = function(x) round(calculate_rsd(x), 3))
  # Rename columns
  colnames(batch_rsd) <- c("Batch", "RSD")
  # Calculate interday RSD, rounding to two decimal places
  interday_rsd <- round(calculate_rsd(data[[mz_value]]), 3)
  # Create a new row for interday RSD
  interday_row <- data.frame(Batch = "Interday", RSD = interday_rsd)
  # Combine batch_rsd with interday_rsd
  batch_rsd <- rbind(batch_rsd, interday_row)
  # Replace all RSD values with percentage symbol
  batch_rsd$RSD <- paste0(batch_rsd$RSD, "%")
  # Replace batch labels with "Intraday 1", "Intraday 2", "Intraday 3"
  batch_rsd$Batch <- ifelse(batch_rsd$Batch == "Interday", "Interday", paste0("Intraday ", batch_rsd$Batch))
  
  return(batch_rsd)
}
```
:::

::: {#no_norm_rsd .cell .r}
```{r}
## QCS RSD Calculation ##
# No Normalization dataset #
# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_2, sample_set_2)
batch_info_columns <- qcs_batch_info_data[, 1:2, drop = FALSE]
# extract qcs data
QCS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == QCS_mz_value_2, drop = FALSE]
QCS_data <- cbind(batch_info_columns, QCS_peak_data)

IS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == IS_mz_value_2, drop = FALSE]
IS_data <- cbind(batch_info_columns, IS_peak_data)

# usage:
rsd_QCS <- calculate_batch_rsd(QCS_data, QCS_mz_value_2)
cat("\033[1mSucessfully calculated rsd (QCS) for no normalization dataset.\033[0m\n")
cat("m/z value:", QCS_mz_value_2, "\n")
print(rsd_QCS)
                           
rsd_IS <- calculate_batch_rsd(IS_data, IS_mz_value_2)
cat("\033[1mSucessfully calculated rsd (Internal Standard) for no normalization dataset.\033[0m\n")
cat("m/z value:", IS_mz_value_2, "\n")
print(rsd_IS)
```
:::

::: {#tic_norm_rsd .cell .r}
```{r}
## QCS RSD Calculation ##
# TIC Normalization Dataset #
# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_TIC_2, sample_set_2)
batch_info_columns <- qcs_batch_info_data[, 1:2, drop = FALSE]

# extract qcs data
QCS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == QCS_mz_value_2, drop = FALSE]
QCS_data_TIC <- cbind(batch_info_columns, QCS_peak_data)

IS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == IS_mz_value_2, drop = FALSE]
IS_data_TIC <- cbind(batch_info_columns, IS_peak_data)

# usage                      
rsd_QCS_TIC <- calculate_batch_rsd(QCS_data_TIC, QCS_mz_value_2)
cat("\033[1mSucessfully calculated rsd (QCS) for TIC normalization dataset.\033[0m\n")
cat("m/z value:", QCS_mz_value_2, "\n")
print(rsd_QCS_TIC)
                           
rsd_IS_TIC <- calculate_batch_rsd(IS_data_TIC, IS_mz_value_2)
cat("\033[1mSucessfully calculated rsd (Internal Standard) for TIC normalization dataset.\033[0m\n")
cat("m/z value:", QCS_mz_value_2, "\n")
print(rsd_IS_TIC)
```
:::

::: {#is_norm_rsd .cell .r}
```{r}
## QCS RSD Calculation ## 
# IS Normalization Dataset #
rsd_ratio <- calculate_batch_rsd(ratio_data, "ratio")
cat("\033[1mSucessfully calculated rsd (QCS / Internal Standard) for IS normalization dataset.\033[0m\n")
cat("m/z value:", "IS_Norm", "\n")
print(rsd_ratio)
```
:::

::: {#rsd_overview .cell .r}
```{r}
## Load required libraries
library(kableExtra)

## Create Overview RSD Table
overview_table_QCS <- data.frame(
  Batch = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
  No_Norm_RSD = rsd_QCS[,2],
  TIC_Norm_RSD = rsd_QCS_TIC[,2],
  IS_Norm_RSD = rsd_ratio[,2]
)
colnames(overview_table_QCS) <- c("Batch", "No_norm", "TIC_norm", "IS_norm")

## Display the table in R Markdown
kable(overview_table_QCS, format = "html", row.names = FALSE) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  add_header_above(c("Overview RSD Table QCS" = 4))  
```
:::

::: {#rsd_overview2 .cell .r}
```{r}
## Overview RSD Table ##
library(kableExtra)

## Create Overview RSD Table
overview_table_IS <- data.frame(
  Batch = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
  No_Norm_RSD = rsd_QCS[,2],
  TIC_Norm_RSD = rsd_QCS_TIC[,2],
  IS_Norm_RSD = rsd_ratio[,2]
)
colnames(overview_table_QCS) <- c("Batch", "No_norm", "TIC_norm", "IS_norm")


## Display the table in R Markdown
kable(overview_table_QCS, format = "html", row.names = FALSE) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  add_header_above(c("Overview RSD Table QCS" = 4))  

## Overview RSD Table ##
library(kableExtra)
library(IRdisplay)

# Dynamically create the overview table
overview_table_IS <- data.frame(
  Row_Names = rsd_IS$Batch,
  No_Norm_RSD = rsd_IS$RSD,
  TIC_Norm_RSD = rsd_IS_TIC$RSD
)

# Displaying RSD table
display_rsd_table_IS <- kable(overview_table_IS, format = "html", row.names = FALSE) %>%
  kable_styling(full_width = FALSE)

# Add table name
display_rsd_table_IS <- paste("<h2 style='text-align: center;'>Overview RSD Table Internal Standard</h2>", 
                               as.character(display_rsd_table_IS))

# Set the column names dynamically
colnames(overview_table_IS) <- c("Batch", "No_norm", "TIC_norm")
print(overview_table_IS)
```
:::

::: {#intensity .cell .markdown}
## 2. QCS Intensity Plot {#qcs_intensity_2}
:::

::: {#intensity2 .cell .r}
```{r}
# Intensity Plot (Intensity vs Measurement Order)

# extract only qcs
extract_qcs_data <- function(dataset, sample_set) {
  pattern <- paste(sample_set, collapse = "|")
  
  # Extract tissue rows
  tissue_rows <- grep(pattern, rownames(dataset))
  
  # Subset dataframe to exclude tissue rows
  qcs_data <- dataset[-tissue_rows, , drop = FALSE]
  
  return(qcs_data)
}

## No Normalization Data ##
# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_2, sample_set_2)

# ordering by batch then s_value
qcs_batch_info_data_ordered <- qcs_batch_info_data[order(qcs_batch_info_data$batch), ]
batch <- qcs_batch_info_data_ordered$batch

# extract s_value
row_names_qcs <- rownames(qcs_batch_info_data_ordered)
s_values <- as.numeric(sub(".*S(\\d+).*", "\\1", row_names_qcs))

qcs_batch_info_data_ordered$S <- s_values
qcs_batch_info_data_ordered <- qcs_batch_info_data_ordered[order(qcs_batch_info_data_ordered$batch, qcs_batch_info_data_ordered$S), ]

QCS_intensity <- qcs_batch_info_data_ordered[,colnames(qcs_batch_info_data_ordered) == QCS_mz_value_2, drop = FALSE]
QCS_intensity_values <- as.numeric(unlist(QCS_intensity))
QCS_intensity <- scale(QCS_intensity_values)

# intensity plot based on measurement_order
qcs_batch_info_data_ordered$measurement_order <- seq_len(nrow(qcs_batch_info_data_ordered))

plot_data_scaled <- data.frame(
  Measurement_order = qcs_batch_info_data_ordered$measurement_order,
  Batch = qcs_batch_info_data_ordered$batch,
  Intensity = QCS_intensity
)

mean_intensity <- mean(plot_data_scaled$Intensity)
sd_intensity <- sd(plot_data_scaled$Intensity)
batch_unique <- unique(plot_data_scaled$Batch)
cat("\033[1mRed dotted line represents mean intensity (mean(scaled_intensity)). Black dotted lines represent standard deviation.(mean - std)\033[0m\n")

# intensity plot
library(ggplot2)
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired
intensity_plot <- ggplot(plot_data_scaled, aes(x = Measurement_order, y = Intensity, color = factor(Batch))) +
  geom_point(size = 5) +  # color = batch
  geom_line(aes(group = Batch), alpha = 0.5) +  # Add lines between points, grouped by Batch
  geom_hline(yintercept = mean_intensity, linetype = "dotted", color = "red", linewidth = 1) +  # Add black dotted line for mean
  geom_hline(yintercept = mean_intensity + sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean + standard deviation
  geom_hline(yintercept = mean_intensity - sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean - standard deviation
  labs(x = "Measurement_order", y = "Scaled Intensity", color = "Batch") +  
  scale_x_continuous(breaks = seq(5, max(plot_data_scaled$Measurement_order), by = 5)) +  
  scale_color_manual(values = c("1" = "red", "2" = "green", "3" = "blue")) +  
  ggtitle("No Normalization Data") +
  theme(
    plot.title = element_text(size = 25, hjust = 0.5, face = "bold"),  
    axis.title.x = element_text(size = 15, face = "bold"),  
    axis.title.y = element_text(size = 15, face = "bold"),  
    axis.text.x = element_text(size = 10, face = "bold"),  
    axis.text.y = element_text(size = 10, face = "bold")  
  )
print(intensity_plot)

# TIC norm #
# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_TIC_2, sample_set_2)

# ordering by batch then s value)
qcs_batch_info_data_ordered <- qcs_batch_info_data[order(qcs_batch_info_data$batch), ]

batch <- qcs_batch_info_data_ordered$batch
row_names_qcs <- rownames(qcs_batch_info_data_ordered)
s_values <- as.numeric(sub(".*S(\\d+).*", "\\1", row_names_qcs))

qcs_batch_info_data_ordered$S <- s_values
qcs_batch_info_data_ordered <- qcs_batch_info_data_ordered[order(qcs_batch_info_data_ordered$batch, qcs_batch_info_data_ordered$S), ]

QCS_intensity <- qcs_batch_info_data_ordered[,colnames(qcs_batch_info_data_ordered) == QCS_mz_value_2, drop = FALSE]
QCS_intensity_values <- as.numeric(unlist(QCS_intensity))
QCS_intensity <- scale(QCS_intensity_values)

# intensity plot based on measurement_order
qcs_batch_info_data_ordered$measurement_order <- seq_len(nrow(qcs_batch_info_data_ordered))

plot_data_scaled <- data.frame(
  Measurement_order = qcs_batch_info_data_ordered$measurement_order,
  Batch = qcs_batch_info_data_ordered$batch,
  Intensity = QCS_intensity
)

rownames(plot_data_scaled) <- rownames(qcs_batch_info_data_ordered)
#print(plot_data_scaled)

mean_intensity <- mean(plot_data_scaled$Intensity)
sd_intensity <- sd(plot_data_scaled$Intensity)
batch_unique <- unique(plot_data_scaled$Batch)

# Get unique batch values from the data
unique_batches <- unique(plot_data_scaled$Batch)

# Generate colors dynamically based on the number of unique batches
batch_colors <- rainbow(length(unique_batches))
color_mapping <- setNames(batch_colors, unique_batches)

# intensity plot
library(ggplot2)
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired
intensity_plot_TIC <- ggplot(plot_data_scaled, aes(x = Measurement_order, y = Intensity, color = factor(Batch))) +
  geom_point(size = 5) +  # color = batch
  geom_line(aes(group = Batch), alpha = 0.5) +  # Add lines between points, grouped by Batch
  geom_hline(yintercept = mean_intensity, linetype = "dotted", color = "red", linewidth = 1) +  # Add black dotted line for mean
  geom_hline(yintercept = mean_intensity + sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean + standard deviation
  geom_hline(yintercept = mean_intensity - sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean - standard deviation
  labs(x = "Measurement_order", y = "Scaled Intensity", color = "Batch") +  
  scale_x_continuous(breaks = seq(5, max(plot_data_scaled$Measurement_order), by = 5)) +  
  scale_color_manual(values = color_mapping) +  # Use the dynamically generated color mapping
  ggtitle("TIC Normalization Data") +
  theme(
    plot.title = element_text(size = 25, hjust = 0.5, face = "bold"),  
    axis.title.x = element_text(size = 15, face = "bold"),  
    axis.title.y = element_text(size = 15, face = "bold"), 
    axis.text.x = element_text(size = 10, face = "bold"),  
    axis.text.y = element_text(size = 10, face = "bold")  
  )
print(intensity_plot_TIC)

# IS norm #
# get rid of tissue samples and ordering by batch
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_2, sample_set_2)
qcs_batch_info_data_ordered <- qcs_batch_info_data[order(qcs_batch_info_data$batch), ]

# ordering by s-value
row_names_qcs <- rownames(qcs_batch_info_data_ordered)
s_values <- as.numeric(sub(".*S(\\d+).*", "\\1", row_names_qcs))

qcs_batch_info_data_ordered$S <- s_values
qcs_batch_info_data_ordered <- qcs_batch_info_data_ordered[order(qcs_batch_info_data_ordered$batch, qcs_batch_info_data_ordered$S), ]

# assign measurement order
qcs_batch_info_data_ordered$measurement_order <- seq_len(nrow(qcs_batch_info_data_ordered))
batch <- qcs_batch_info_data_ordered$batch

QCS_intensity <- qcs_batch_info_data_ordered[,colnames(qcs_batch_info_data_ordered) == QCS_mz_value_2, drop = FALSE] 
QCS_intensity_values <- as.numeric(unlist(QCS_intensity))

IS_intensity <- qcs_batch_info_data_ordered[,colnames(qcs_batch_info_data_ordered) == IS_mz_value_2, drop = FALSE] 
IS_intensity_values <- as.numeric(unlist(IS_intensity))

ratio_intensity <- QCS_intensity_values / IS_intensity_values
ratio_intensity <- scale(ratio_intensity)

# making data frame
plot_data_scaled <- data.frame(
  Measurement_order = qcs_batch_info_data_ordered$measurement_order,
  Batch = qcs_batch_info_data_ordered$batch,
  Intensity = ratio_intensity
)
mean_intensity <- mean(plot_data_scaled$Intensity)
sd_intensity <- sd(plot_data_scaled$Intensity)
batch_unique <- unique(plot_data_scaled$Batch)

# Get unique batch values from the data
unique_batches <- unique(plot_data_scaled$Batch)

# Generate colors dynamically based on the number of unique batches
batch_colors <- rainbow(length(unique_batches))
color_mapping <- setNames(batch_colors, unique_batches)

# intensity plot
library(ggplot2)
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired
intensity_plot_IS <- ggplot(plot_data_scaled, aes(x = Measurement_order, y = Intensity, color = factor(Batch))) +
  geom_point(size = 5) +  # color = batch
  geom_line(aes(group = Batch), alpha = 0.5) +  # Add lines between points, grouped by Batch
  geom_hline(yintercept = mean_intensity, linetype = "dotted", color = "red", linewidth = 1) +  # Add black dotted line for mean
  geom_hline(yintercept = mean_intensity + sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean + standard deviation
  geom_hline(yintercept = mean_intensity - sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean - standard deviation
  labs(x = "Measurement_order", y = "Scaled Intensity", color = "Batch") +  
  scale_x_continuous(breaks = seq(5, max(plot_data_scaled$Measurement_order), by = 5)) + 
  scale_color_manual(values = color_mapping) +  # Include scale_color_manual within ggplot() function
  ggtitle("IS Normalization Data") +
  theme(
    plot.title = element_text(size = 25, hjust = 0.5, face = "bold"),  
    axis.title.x = element_text(size = 15, face = "bold"),  
    axis.title.y = element_text(size = 15, face = "bold"),  
    axis.text.x = element_text(size = 10, face = "bold"),  
    axis.text.y = element_text(size = 10, face = "bold")  
  )
print(intensity_plot_IS)
```
:::

::: {#intensity_plot2 .cell .r}
## Overview of Intensity Plot

```{r fig.height=12, fig.width=7, echo=FALSE}
# Display combined only
library(gridExtra)
combined_intensity_plot <- grid.arrange(intensity_plot,
                                        intensity_plot_TIC,
                                        intensity_plot_IS,
                                        ncol = 1,
                                        heights = c(1,1,1))
```
:::

::: {#violin_plot .cell .markdown}
## 3. QCS Violin Plot {#qcs_violin_2}

Violin plot represents the spreadout and variability of the QCS samples
(both propranolol and D7_propranolol for example). It would have QCS
peak intensity on the y-axis while each violins would represent each
slide on the x-axis. It is scaled by its mean.
:::

::: {#violin_plot1 .cell .r}
```{r}
## Violin Plot ##

# Load library
library(ggplot2)
library(dplyr)
library(RColorBrewer)

# Function to scale data by its mean
scale_by_mean <- function(data_frame) {
  mean_value <- mean(data_frame$Value)
  sd_value <- sd(data_frame$Value)  
  data_frame <- data_frame %>%
    mutate(Value = (Value - mean_value) / sd_value) # Z-score normalization
  return(data_frame)
}

# No Normalization Dataset #
# Transform and prepare the dataset
QCS_data_trans <- as.data.frame(t(QCS_data))
QCS_data_trans[] <- lapply(QCS_data_trans, as.numeric)

# Extract slide number
slide_number <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans))
slide_number <- as.numeric(slide_number)

# Create violin plot data frame
violin_data <- data.frame(
  Slide = slide_number,
  Batch = QCS_data$batch,
  Value = unlist(QCS_data_trans[3, ])
)

# Scale No Normalization data by its mean
violin_data <- scale_by_mean(violin_data)

# TIC Normalization Dataset #
# Transform and prepare the dataset
QCS_data_trans_TIC <- as.data.frame(t(QCS_data_TIC))
QCS_data_trans_TIC[] <- lapply(QCS_data_trans_TIC, as.numeric)

# Extract slide number
slide_number_TIC <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_TIC))
slide_number_TIC <- as.numeric(slide_number_TIC)

# Create violin plot data frame
violin_data_TIC <- data.frame(
  Slide = slide_number_TIC,
  Batch = QCS_data$batch,
  Value = unlist(QCS_data_trans_TIC[3, ])
)

# Scale TIC Normalization data by its mean
violin_data_TIC <- scale_by_mean(violin_data_TIC)

# IS Normalization Dataset #
# Transform and prepare the dataset
QCS_data_trans_IS <- as.data.frame(t(ratio_data))
QCS_data_trans_IS[] <- lapply(QCS_data_trans_IS, as.numeric)

# Extract slide number
slide_number_IS <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_IS))
slide_number_IS <- as.numeric(slide_number_IS)

# Create violin plot data frame
violin_data_IS <- data.frame(
  Slide = slide_number_IS,
  Batch = ratio_data$batch,
  Value = unlist(QCS_data_trans_IS[3, ])
)

# Scale IS Normalization data by its mean
violin_data_IS <- scale_by_mean(violin_data_IS)

# Define the colors for the first three batches
manual_colors <- c("1" = "red", "2" = "green", "3" = "blue")

# Plot function to ensure consistent scaling
plot_violin <- function(data, title) {
  unique_batches <- unique(data$Batch)
  additional_batches <- setdiff(unique_batches, names(manual_colors))
  
  if (length(additional_batches) > 0) {
    additional_colors <- colorRampPalette(brewer.pal(9, "Set3"))(length(additional_batches))
    additional_colors <- setNames(additional_colors, additional_batches)
  } else {
    additional_colors <- c()
  }
  
  all_colors <- c(manual_colors, additional_colors)
  
  ggplot(data, aes(x = factor(Slide), y = Value, fill = factor(Batch))) +
    geom_violin(position = position_dodge(width = 0.5), trim = FALSE, width = 1) +
    stat_summary(fun = median, geom = "point", shape = 20, size = 3, color = "black") +
    geom_point(position = position_jitter(width = 0.1), alpha = 0.5) + 
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray", linewidth = 1) +
    scale_fill_manual(values = all_colors) +
    labs(x = "Slide Number", y = "Scaled Peak Data", title = title) +
    theme_bw() +
    theme(

      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 15),
      axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 15),
      axis.title = element_text(face = "bold", size = 15),  
      plot.title = element_text(face = "bold", size = 25),  
      axis.text = element_text(size = 15)
    )
}

# Plot the data with each dataset scaled by its mean
cat("\033[1mGray dotted line represents median\033[0m\n")
options(repr.plot.width = 10, repr.plot.height = 6)

# No Normalization Plot
violin_plot_jit <- plot_violin(violin_data, "No Normalization (QCS)")
print(violin_plot_jit)

# TIC Normalization Plot
violin_plot_TIC_jit <- plot_violin(violin_data_TIC, "TIC Normalization (QCS)")
print(violin_plot_TIC_jit)

# IS Normalization Plot
violin_plot_IS_jit <- plot_violin(violin_data_IS, "IS Normalization (QCS)")
print(violin_plot_IS_jit)
```
:::

::: {#violin_plot3 .cell .r}
```{r, fig.height=10, fig.width=7}
# Overview Violin Plot (Propranolol)
library(gridExtra)
combined_violin_plot <- grid.arrange(violin_plot_jit,
                                     violin_plot_TIC_jit,
                                     violin_plot_IS_jit,
                                     ncol = 1,
                                     heights = c(1,1,1))
```
:::

::: {#violin_plot4 .cell .r}
```{r}
## Violin Plot ##

# Load library
library(ggplot2)
library(dplyr)
library(RColorBrewer)

# Function to scale data by its mean
scale_by_mean <- function(data_frame) {
  mean_value <- mean(data_frame$Value)
  sd_value <- sd(data_frame$Value)  
  data_frame <- data_frame %>%
    mutate(Value = (Value - mean_value) / sd_value) # Z-score normalization
  return(data_frame)
}


# No Normalization Dataset #
# Transform and prepare the dataset
QCS_data_trans <- as.data.frame(t(IS_data))
QCS_data_trans[] <- lapply(QCS_data_trans, as.numeric)

# Extract slide number
slide_number <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans))
slide_number <- as.numeric(slide_number)

# Create violin plot data frame
violin_data <- data.frame(
  Slide = slide_number,
  Batch = QCS_data$batch,
  Value = unlist(QCS_data_trans[3, ])
)

# Scale No Normalization data by its mean
violin_data <- scale_by_mean(violin_data)

# Sort the data frame based on the Slide column
violin_data <- violin_data %>%
  arrange(Slide)

# Define the colors for the first three batches
manual_colors <- c("1" = "red", "2" = "green", "3" = "blue")

# Get the unique batches in your data
unique_batches <- unique(violin_data$Batch)

# Determine the number of additional batches
additional_batches <- setdiff(unique_batches, names(manual_colors))

# Generate additional colors using a color ramp palette
if (length(additional_batches) > 0) {
  additional_colors <- colorRampPalette(brewer.pal(9, "Set3"))(length(additional_batches))
  additional_colors <- setNames(additional_colors, additional_batches)
} else {
  additional_colors <- c()
}

# Combine the manually defined colors with the additional colors
all_colors <- c(manual_colors, additional_colors)

# Plot the No Normalization data
cat("\033[1mGray dotted line represents median\033[0m\n")
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired
violin_plot_jit_d7 <- ggplot(violin_data, aes(x = factor(Slide), y = Value, fill = factor(Batch))) +
  geom_violin(position = position_dodge(width = 0.5), trim = FALSE, width = 1) +
  stat_summary(fun = median, geom = "point", shape = 20, size = 3, color = "black") +
  geom_point(position = position_jitter(width = 0.1), alpha = 0.5) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray", linewidth = 1) +
  scale_fill_manual(values = all_colors) +
  labs(x = "Slide Number", y = "Scaled Peak Data", title = "No Normalization (Internal Standard)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 15),
    axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 15),
    axis.title = element_text(face = "bold", size = 15),  
    plot.title = element_text(face = "bold", size = 25),  
    axis.text = element_text(size = 15)  
  )
print(violin_plot_jit_d7)

# TIC Normalization Dataset #
# Transform and prepare the dataset
QCS_data_trans_TIC <- as.data.frame(t(IS_data_TIC))
QCS_data_trans_TIC[] <- lapply(QCS_data_trans_TIC, as.numeric)

# Extract slide number
slide_number_TIC <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_TIC))
slide_number_TIC <- as.numeric(slide_number_TIC)

# Create violin plot data frame
violin_data_TIC <- data.frame(
  Slide = slide_number_TIC,
  Batch = QCS_data$batch,
  Value = unlist(QCS_data_trans_TIC[3, ])
)

# Scale TIC Normalization data by its mean
violin_data_TIC <- scale_by_mean(violin_data_TIC)

# Sort the data frame based on the Slide column
violin_data_TIC <- violin_data_TIC %>%
  arrange(Slide)

# Define the colors for the first three batches
manual_colors <- c("1" = "red", "2" = "green", "3" = "blue")

# Get the unique batches in your data
unique_batches <- unique(violin_data_TIC$Batch)

# Determine the number of additional batches
additional_batches <- setdiff(unique_batches, names(manual_colors))

# Generate additional colors using a color ramp palette
if (length(additional_batches) > 0) {
  additional_colors <- colorRampPalette(brewer.pal(9, "Set3"))(length(additional_batches))
  additional_colors <- setNames(additional_colors, additional_batches)
} else {
  additional_colors <- c()
}

# Combine the manually defined colors with the additional colors
all_colors <- c(manual_colors, additional_colors)

# Plot the TIC normalization data
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired
violin_plot_TIC_jit_d7 <- ggplot(violin_data_TIC, aes(x = factor(Slide), y = Value, fill = factor(Batch))) +
  geom_violin(position = position_dodge(width = 0.5), trim = FALSE, width = 1) +
  stat_summary(fun = median, geom = "point", shape = 20, size = 3, color = "black") +
  geom_point(position = position_jitter(width = 0.1), alpha = 0.5) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray", linewidth = 1) +
  scale_fill_manual(values = all_colors) +
  labs(x = "Slide Number", y = "Scaled Peak Data", title = "TIC Normalization (Internal Standard)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 15),
    axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 15),
    axis.title = element_text(face = "bold", size = 15),  
    plot.title = element_text(face = "bold", size = 25),  
    axis.text = element_text(size = 15) 
  )
print(violin_plot_TIC_jit_d7)
```
:::

::: {.cell .r}
## Overview Violin Plot

```{r, fig.height=10, fig.width=7}
# Overview Violin Plot (Internal Standard)
library(gridExtra)
combined_violin_plot_IS <- grid.arrange(violin_plot_jit_d7,
                                     violin_plot_TIC_jit_d7,
                                     ncol = 1,
                                     heights = c(1,1,1))
```
:::

::::: {#pca_plot .cell .markdown}
## 4. PCA Plot {#pca_2}

::: {#pca_plot2 .cell .r}
```{r}
## PCA plot ##
# no norm #
library(ggplot2)
library(stringr)
library(zoo)
library(dplyr)

# Format PCA plot 
cat("\033[1mPCA plot for no normalization dataset\033[0m\n")

# Convert all columns combined_batch_data_df as numeric
combined_batch_data_df_numeric <- combined_batch_data_df_2 %>%
  mutate_all(as.numeric)

# Extract combined_batch_data df 
adjusted <- combined_batch_data_df_numeric[, -(1:3)]
batch_matrix <- data.frame(adjusted)
sample_ID <- str_extract(colnames(batch_matrix), "(S|m/z)\\d+")

# Create the regular expression pattern for sample_set
pattern <- paste(sample_set_2, collapse = "|")

# Extract sample types from column names using the defined pattern
sample_types <- str_extract(colnames(batch_matrix), pattern)
sample_types[is.na(sample_types)] <- "QCS"

# Transpose the data so that samples are on rows and features on columns
batch_data_t <- t(as.matrix(batch_matrix))

# Create a new data frame with the transposed matrix
batch_data_t_df <- as.data.frame(batch_data_t)

# Perform PCA, assuming batch_data_t_df contains the transposed data
batch_pca <- prcomp(batch_data_t_df, center = TRUE, scale. = TRUE)

# Create a data frame for plotting the PCA
pca_data <- data.frame(Sample = sample_ID, batch_pca$x)

# Plot PCA with colored sample dots based on sample type
pca_data$Score <- pca_data$PC1 + pca_data$PC2
pca_data$Type <- sample_types

# Calculate the PC1 and PC2 scores
pc1_score <- batch_pca$sdev[1]^2
pc2_score <- batch_pca$sdev[2]^2

# Calculate the total score as the sum of PC1 and PC2 scores
total_score <- pc1_score + pc2_score

# Display the score 
total_score_text_recon <- paste("Total Score:", round(total_score / sum(batch_pca$sdev^2) * 100, 2), "%")
cat(total_score_text_recon)

# Generate a color palette for tissue types, with "QCS" always in black
unique_types <- unique(sample_types[sample_types != "QCS"])
color_palette <- scales::hue_pal()(length(unique_types))
color_mapping <- c("QCS" = "black", setNames(color_palette, unique_types))

# PCA plot
plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = Type, label = Sample)) +
  geom_point(size = 5) +
  geom_text(hjust = 1.5, vjust = 1.5, size = 8, check_overlap = TRUE, show.legend = FALSE) +
  xlab(paste("PC1 - ", round(batch_pca$sdev[1]^2 / sum(batch_pca$sdev^2) * 100, 2), "% Variance")) +
  ylab(paste("PC2 - ", round(batch_pca$sdev[2]^2 / sum(batch_pca$sdev^2) * 100, 2), "% Variance")) +
  ggtitle("No Normalization Data") +
  labs(color = "Sample Types") + 
  scale_color_manual(values = color_mapping) +  # Apply custom colors
  theme_bw() +
  theme(
    legend.position = "right",
    legend.title = element_text(size = 10, face = 'bold'),
    legend.text = element_text(size = 10),
    axis.text = element_text(size = 25, face = 'bold'), 
    axis.title = element_text(size = 25, face = 'bold'),
    plot.title = element_text(size = 40, hjust = 0.5, face = 'bold')
  )
print(plot)
```
:::

::: {#pca_plot3 .cell .r}
```{r}
## PCA plot ##
# TIC norm #
library(ggplot2)
library(stringr)
library(zoo)
library(dplyr)

# Format PCA plot
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired
cat("\033[1mPCA plot for TIC normalization dataset\033[0m\n")

# Convert all columns combined_batch_data_df as numeric
combined_batch_data_df_numeric <- combined_batch_data_df_TIC_2 %>%
  mutate_all(as.numeric)

# Extract combined_batch_data df 
adjusted <- combined_batch_data_df_numeric[, -(1:3)]
batch_matrix <- data.frame(adjusted)
sample_ID <- str_extract(colnames(batch_matrix), "(S|m/z)\\d+")

# Create the regular expression pattern for sample_set
pattern <- paste(sample_set_2, collapse = "|")

# Extract sample types from column names using the defined pattern
sample_types_TIC <- str_extract(colnames(batch_matrix), pattern)
sample_types_TIC[is.na(sample_types_TIC)] <- "QCS"

# Transpose the data so that samples are on rows and features on columns
batch_data_t <- t(as.matrix(batch_matrix))

# Create a new data frame with the transposed matrix
batch_data_t_df <- as.data.frame(batch_data_t)

# Perform PCA, assuming batch_data_t_df contains the transposed data
batch_pca_TIC <- prcomp(batch_data_t_df, center = TRUE, scale. = TRUE)

# Create a data frame for plotting the PCA
pca_data_TIC <- data.frame(Sample = sample_ID, batch_pca_TIC$x)

# Plot PCA with colored sample dots based on sample type
pca_data_TIC$Score <- pca_data_TIC$PC1 + pca_data_TIC$PC2
pca_data_TIC$Type <- sample_types_TIC

# Calculate the PC1 and PC2 scores
pc1_score <- batch_pca_TIC$sdev[1]^2
pc2_score <- batch_pca_TIC$sdev[2]^2

# Calculate the total score as the sum of PC1 and PC2 scores
total_score <- pc1_score + pc2_score

# Display the score 
total_score_text_recon <- paste("Total Score:", round(total_score / sum(batch_pca_TIC$sdev^2) * 100, 2), "%")
cat(total_score_text_recon)

# Generate a color palette for tissue types, with "QCS" always in black
unique_types <- unique(sample_types_TIC[sample_types_TIC != "QCS"])
color_palette <- scales::hue_pal()(length(unique_types))
color_mapping <- c("QCS" = "black", setNames(color_palette, unique_types))

# PCA plot
plot_TIC <- ggplot(pca_data_TIC, aes(x = PC1, y = PC2, color = Type, label = Sample)) +
  geom_point(size = 5) +
  geom_text(hjust = 1.5, vjust = 1.5, size = 8, check_overlap = TRUE, show.legend = FALSE) +
  xlab(paste("PC1 - ", round(batch_pca_TIC$sdev[1]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2), "% Variance")) +
  ylab(paste("PC2 - ", round(batch_pca_TIC$sdev[2]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2), "% Variance")) +
  ggtitle("TIC Normalization Data") +
  labs(color = "Sample Types") + 
  scale_color_manual(values = color_mapping) +  # Apply custom colors
  theme_bw() +
  theme(
    legend.position = "right",
    legend.title = element_text(size = 10, face = 'bold'),
    legend.text = element_text(size = 10),
    axis.text = element_text(size = 25, face = 'bold'), 
    axis.title = element_text(size = 25, face = 'bold'),
    plot.title = element_text(size = 40, hjust = 0.5, face = 'bold')
  ) 
print(plot_TIC)
```
:::
:::::

```{r, fig.height=10, fig.width=7}
## Overview PCA Plot ##
library(gridExtra)
combined_plots <- grid.arrange(plot,
                               plot_TIC,
                               ncol = 1,
                               heights = c(1,1))
print(combined_plots)
```

:::

:::: {#pca plot .cell .markdown} \## 5. QCS PCA Plot {#qcs_pca_2} The
QCS PCA Plot illustrates a distribution of QCS samples only. The black
triangle represents the centroid of the QCS samples and dots represent
individual QCS samples with their corresponding batches as the colors.
The Average Euclidean Distance is below the PCA plot which was
calculated by the following formula, where Euclidean distance is
measured between the individual sample and the centroid of the sample
and we averaged it.

::: {style="text-align: center;"}
<img src="image/QCS_Distance.png" alt="QCS_Distance" style="width:80%;"/>
:::

::::

::: {#qcs_pca_plot3 .cell .r}
```{r}
## PCA plot of QCS ##
# No Normalization Data #
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(cowplot)
library(gridExtra)

# Gets rid of plot format
options(repr.plot.width = NULL, repr.plot.height = NULL)

# Calculate PCA scores
pca_scores <- batch_pca$x

# Identify QCS samples based on sample types
qcs_samples <- which(sample_types == "QCS")

# Extract PCA scores for QCS samples
qcs_scores <- pca_scores[qcs_samples, 1:2] # only obtaining PC1 and PC2

# Compute the centroid of QCS samples
qcs_centroid <- colMeans(qcs_scores)

# Add batch info
qcs_batch_info <- batch_info_2[qcs_samples, "batch"]

qcs_data <- data.frame(
  PC1 = qcs_scores[, 1],
  PC2 = qcs_scores[, 2],
  Batch = as.factor(qcs_batch_info)
)

# Calculate PC1 and PC2 variances
pc1_variance <- round(batch_pca$sdev[1]^2 / sum(batch_pca$sdev^2) * 100, 2)
pc2_variance <- round(batch_pca$sdev[2]^2 / sum(batch_pca$sdev^2) * 100, 2)

# Calculate distance between individuals samples and PC1 or PC2 centroids
coordinate_PC1 <- (qcs_scores[, 1] - qcs_centroid["PC1"])^2
coordinate_PC2 <- (qcs_scores[, 2] - qcs_centroid["PC2"])^2

# Add up distances of each coordinate as one and square root them
distance_from_centroid <- sqrt(coordinate_PC1 + coordinate_PC2)

# Average the distances
average_distance_ec <- mean(distance_from_centroid)

# Plot PCA plot with QCS samples and their centroid
pca_plot_qcs <- ggplot(qcs_data, aes(x = PC1, y = PC2, color = Batch)) +
  geom_point(size = 7) +  # Plot QCS samples with color based on batch number
  geom_point(data = data.frame(PC1 = qcs_centroid[1], PC2 = qcs_centroid[2]), aes(x = PC1, y = PC2), shape = 17, fill = "black", color = "black", size = 5) +  # Plot centroid as triangle with filled red color
  labs(x = paste("PC1 (", pc1_variance, "% Variance)"), y = paste("PC2 (", pc2_variance, "% Variance)"), title = "No Normalization Data (QCS)") +
  theme_bw() +
  theme(axis.title.x = element_text(face = "bold", size = 15),
        axis.title.y = element_text(face = "bold", size = 15),
        axis.text = element_text(size = 15, face = "bold"),
        plot.margin = margin(20, 50, 10, 50),  
        plot.title = element_text(face = "bold", size = 20))

# Creating data frame for average distance
average_distance_qcs_df <- data.frame(
    Pair = 'Average Euclidean Distance',
    Distance = round(average_distance_ec, 3)
    )
    
# Create a table plot
table_plot_qcs <- tableGrob(average_distance_qcs_df, theme = ttheme_minimal(base_size = 20), rows = NULL)

# Combine the PCA plot and the table
combined_plot_qcs <- plot_grid(pca_plot_qcs, table_plot_qcs, ncol = 1, align = "v", axis = "lr", rel_heights = c(3, 1))

cat("\033[1mQCS PCA plot for no normalization dataset. Black triangle represents centroid of dataset. Value underneath represents average distance of QCS from centroid.\033[0m\n")

# Print the combined plot
print(combined_plot_qcs)
```
:::

::: {#qcs_pca_plot4 .cell .r}
```{r}
## PCA plot of QCS ##
# TIC normalization data
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(cowplot)
library(gridExtra)

# Gets rid of plot format
options(repr.plot.width = NULL, repr.plot.height = NULL)

# Calculate PCA scores
pca_scores <- batch_pca_TIC$x

# Identify QCS samples based on sample types
qcs_samples <- which(sample_types_TIC == "QCS")

# Extract PCA scores for QCS samples
qcs_scores <- pca_scores[qcs_samples, 1:2] # only obtaining from PC1 and PC2

# Compute the centroid of QCS samples
qcs_centroid <- colMeans(qcs_scores)

# Add batch info
qcs_batch_info <- batch_info_2[qcs_samples, "batch"]
qcs_data <- data.frame(
  PC1 = qcs_scores[, 1],
  PC2 = qcs_scores[, 2],
  Batch = as.factor(qcs_batch_info)
)

# Calculate PC1 and PC2 variances
pc1_variance <- round(batch_pca_TIC$sdev[1]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2)
pc2_variance <- round(batch_pca_TIC$sdev[2]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2)


# Calculate distance between individuals samples and PC1 or PC2 centroids
coordinate_PC1 <- (qcs_scores[, 1] - qcs_centroid["PC1"])^2
coordinate_PC2 <- (qcs_scores[, 2] - qcs_centroid["PC2"])^2

# Add up distances of each coordinate as one and square root them
distance_from_centroid <- sqrt(coordinate_PC1 + coordinate_PC2)

# Average the distances
average_distance_ec_TIC <- mean(distance_from_centroid)

# Plot PCA plot with QCS samples and their centroid
pca_plot_qcs <- ggplot(qcs_data, aes(x = PC1, y = PC2, color = Batch)) +
  geom_point(size = 7) +  # Plot QCS samples with color based on batch number
  geom_point(data = data.frame(PC1 = qcs_centroid[1], PC2 = qcs_centroid[2]), aes(x = PC1, y = PC2), shape = 17, fill = "black", color = "black", size = 5) +  # Plot centroid as triangle with filled red color
  labs(x = paste("PC1 (", pc1_variance, "% Variance)"), y = paste("PC2 (", pc2_variance, "% Variance)"), title = "TIC Normalization Data (QCS)") +
  theme_bw() +
  theme(axis.title.x = element_text(face = "bold", size = 15),
        axis.title.y = element_text(face = "bold", size = 15),
        axis.text = element_text(size = 15, face = "bold"),
        plot.margin = margin(20, 50, 10, 50),  
        plot.title = element_text(face = "bold", size = 20))

# Creating data frame for average distance
average_distance_TIC_qcs_df <- data.frame(
    Pair = 'Average Euclidean Distance',
    Distance = round(average_distance_ec_TIC, 3)
    )
    
# Create a table plot
table_plot_qcs <- tableGrob(average_distance_TIC_qcs_df, theme = ttheme_minimal(base_size = 20), rows = NULL)

# Combine the PCA plot and the table
combined_plot_TIC_qcs <- plot_grid(pca_plot_qcs, table_plot_qcs, ncol = 1, align = "v", axis = "lr", rel_heights = c(3, 1))

cat("\033[1mQCS PCA plot for TIC normalization dataset. Black triangle represents centroid of dataset. Value underneath represents average distance of QCS from centroid.\033[0m\n")

# Print the combined plot
print(combined_plot_TIC_qcs)
```
:::

::: {.cell .r}
```{r, fig.height=10, fig.width=7}
## Overview QCS PCA PLOT ##
library(gridExtra)
combined_plots <- grid.arrange(combined_plot_qcs,
                               combined_plot_TIC_qcs,
                               ncol = 1,
                               heights = c(1,1))
print(combined_plots)
```
:::

::: {#tissue_eval.cell .markdown}
## Tissue Evaluation {#tissue_evaluation_2}

## 1. Tissue RSD {#tissue_rsd}
:::

::: {.cell .r}
```{r}
## run these functions first ## 

# 1: Function to calculate rsd for tissue
calculate_batch_rsd_combined <- function(tissue_samples) {
  
  calculate_batch_rsd <- function(sample_dataset, batch_number) {
    # Extract data for the specified batch number
    batch_data <- sample_dataset[sample_dataset$batch == batch_number, -(1:2)]
    # Check if there are any samples for this batch
    if (nrow(batch_data) == 0) {
      return("NA  NA%")  # Return NA if no samples exist for this batch
    }
    
    # Calculate mean and standard deviation for each analyte
    means <- apply(batch_data, 2, mean, na.rm = TRUE)
    std_devs <- apply(batch_data, 2, sd, na.rm = TRUE)

    # Calculate RSD
    rsd <- (std_devs / means) * 100
    
    # Calculate mean RSD and standard deviation of RSD
    mean_rsd <- mean(rsd)
    std_rsd <- sd(rsd)
    
    # Format the results
    rsd_formatted <- sprintf("%.2f  %.2f%%", mean_rsd, std_rsd)
    
    # Return the formatted RSD
    return(rsd_formatted)
  }
  
  calculate_interday_rsd <- function(sample_dataset) {
    # Extract data for interday calculation
    interday_data <- sample_dataset[, -(1:2)]
    
    # Check if there are any samples for interday calculation
    if (nrow(interday_data) == 0) {
      return("NA  NA%")  # Return NA if no interday samples exist
    }
    
    # Calculate mean and standard deviation for each analyte
    means <- apply(interday_data, 2, mean, na.rm = TRUE)
    std_devs <- apply(interday_data, 2, sd, na.rm = TRUE)
    
    # Calculate RSD
    rsd <- (std_devs / means) * 100
    
    # Calculate mean RSD and standard deviation of RSD
    mean_rsd <- mean(rsd)
    std_rsd <- sd(rsd)
    
    # Format the results
    rsd_formatted <- sprintf("%.2f  %.2f%%", mean_rsd, std_rsd)
    
    # Return the formatted RSD
    return(rsd_formatted)
  }
  
  calculate_batch_rsd_multiple <- function(sample_dataset, unique_batches) {
    rsd_results <- list()
    for (batch_number in unique_batches) {
      rsd_results[[as.character(batch_number)]] <- calculate_batch_rsd(sample_dataset, batch_number)
    }
    return(rsd_results)
  }
  
  unique_tissues <- unique(gsub(".*_(\\w+)_\\d+.*", "\\1", rownames(tissue_samples)))
  
  rsd_results <- list()
  
  for (tissue_type in unique_tissues) {
    tissue_data <- tissue_samples[grep(paste0(tissue_type, "_"), rownames(tissue_samples)), ]
    
    sample_numbers <- as.numeric(gsub(".*S(\\d+)_.*", "\\1", rownames(tissue_data)))
    ordered_indices <- order(sample_numbers)
    tissue_data <- tissue_data[ordered_indices, ]
    
    tissue_data <- replace(tissue_data, tissue_data < 0, 1)
    
    unique_batches <- unique(tissue_data$batch)
    rsd_results_tissue <- calculate_batch_rsd_multiple(tissue_data, unique_batches)
    
    # Initialize dataframe to store results
    rsd_df_tissue <- data.frame(
      Batch = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
      RSD = NA
    )
    
    # Fill in RSD values where available for batch-specific RSDs
    for (i in 1:length(rsd_df_tissue$Batch)) {
      batch_number <- i  # Adjust based on batch number indexing
      if (as.character(batch_number) %in% names(rsd_results_tissue)) {
        rsd_df_tissue$RSD[i] <- rsd_results_tissue[[as.character(batch_number)]]
      } else {
        rsd_df_tissue$RSD[i] <- "NA  NA%"  # Handle case where batch RSD is missing
      }
    }
    
    # Calculate interday RSD and insert into the dataframe
    interday_rsd <- calculate_interday_rsd(tissue_data)
    rsd_df_tissue$RSD[length(rsd_df_tissue$Batch)] <- interday_rsd
    
    rsd_results[[tissue_type]] <- rsd_df_tissue
  }
  
  return(rsd_results)
}

# 2: Function to gerneate HTML tables for each tissue 
generate_rsd_table <- function(rsd_results, tissue_name) {
  rsd_df <- rsd_results[[tissue_name]]
  kable(rsd_df, format = "html", row.names = FALSE) %>%
    kable_styling(full_width = FALSE)
}
```
:::

::: {#tissue_rsd2 .cell .r}
```{r}
## Tissue Variation RSD ##
# load libraries
library(kableExtra)
library(IRdisplay)

# No Normalization Dataset #
# extract tissue samples based on the rownames
sample_set_regex <- paste(sample_set_2, collapse = "|")
sample_set_rows <- grep(sample_set_regex, rownames(combined_batch_info_data_2))
tissue_samples <- combined_batch_info_data_2[sample_set_rows,]
row_names <- rownames(tissue_samples)
tissue_samples <- as.data.frame(apply(tissue_samples, 2, as.numeric))
rownames(tissue_samples) <- row_names

rsd_results_combined <- calculate_batch_rsd_combined(tissue_samples)
#print(rsd_results_combined)

# Generate HTML tables for each tissue
html_tables <- lapply(names(rsd_results_combined), function(tissue_name) {
  rsd_table <- generate_rsd_table(rsd_results_combined, tissue_name)
  table_name <- paste("<h2 style='text-align: center;'>", tissue_name, " RSD Table</h2>", sep = "")
  paste("<div style='display: inline-block; margin-right: 20px; text-align: center;'>", table_name, as.character(rsd_table), "</div>")
})

# Combine HTML tables into a single string
html_content <- paste(html_tables, collapse = "")

# Wrap the combined HTML content in a div with text-align: center
centered_html_content <- paste("<div style='text-align: center;'>", html_content, "</div>")
cat("\033[1mTissue RSD for No Normalization Data\033[0m\n")
# Display the centered HTML content in JupyterLab
print(centered_html_content)
```
:::

::: {#tissue_rsd3 .cell .r}
```{r}
## Tissue Variation RSD ##
# load libraries
library(kableExtra)
library(IRdisplay)

## TIC Normalization Dataset ##
# extract tissue samples based on the rownames
sample_set_regex <- paste(sample_set_2, collapse = "|")
sample_set_rows <- grep(sample_set_regex, rownames(combined_batch_info_data_TIC_2))
tissue_samples <- combined_batch_info_data_TIC_2[sample_set_rows,]
row_names <- rownames(tissue_samples)
tissue_samples <- as.data.frame(apply(tissue_samples, 2, as.numeric))
rownames(tissue_samples) <- row_names

rsd_results_combined_TIC <- calculate_batch_rsd_combined(tissue_samples)
#print(rsd_results_combined)

# Generate HTML tables for each tissue
html_tables_TIC <- lapply(names(rsd_results_combined_TIC), function(tissue_name) {
  rsd_table <- generate_rsd_table(rsd_results_combined_TIC, tissue_name)
  table_name <- paste("<h2 style='text-align: center;'>", tissue_name, " RSD Table</h2>", sep = "")
  paste("<div style='display: inline-block; margin-right: 20px; text-align: center;'>", table_name, as.character(rsd_table), "</div>")
})

# Combine HTML tables into a single string
html_content_TIC <- paste(html_tables_TIC, collapse = "")

# Wrap the combined HTML content in a div with text-align: center
centered_html_content_TIC <- paste("<div style='text-align: center;'>", html_content_TIC, "</div>")
cat("\033[1mTissue RSD for TIC Normalization Data\033[0m\n")
# Display the centered HTML content in JupyterLab
print(centered_html_content_TIC)
```
:::

::: {.cell .r}
```{r}
## Overview RSD Table ##
# Initialize an empty list to store combined HTML tables for each tissue
combined_html_list <- list()
# Iterate over each tissue type
for (tissue_name in names(rsd_results_combined)) {
  # Extract RSD tables for the current tissue type
  rsd_table <- generate_rsd_table(rsd_results_combined, tissue_name)
  rsd_table_TIC <- generate_rsd_table(rsd_results_combined_TIC, tissue_name)
  
  # Combine HTML tables for the current tissue type horizontally
  combined_rsd_table <- paste("<h2 style='text-align: center;'>", tissue_name, " RSD Table</h2>",
                              "<div style='text-align: center;'>",
                              "<div style='display: inline-block; margin-right: 20px; text-align: center;'>",
                              "<h3>No Normalization</h3>", rsd_table, "</div>",
                              "<div style='display: inline-block; margin-right: 20px; text-align: center;'>",
                              "<h3>TIC Normalization</h3>", rsd_table_TIC, "</div>",
                              "</div>")
  
  # Add the combined HTML table to the list
  combined_html_list[[tissue_name]] <- combined_rsd_table
}

# Combine HTML tables into a single HTML table with two columns
combined_html <- paste("<table style='width:100%; border-collapse: collapse;'>", 
                       "<tr>", paste("<td style='vertical-align: top;'>", 
                                     unlist(combined_html_list), 
                                     "</td>", sep = ""), "</tr></table>")

# Wrap the combined HTML content in a div with text-align: center
centered_combined_html <- paste("<div style='text-align: center;'>", combined_html, "</div>")
# Display the centered HTML content in JupyterLab
print(centered_combined_html)
```
:::

:::: {#tissue_pca2 .cell .r}
## 2. Tissue PCA Plot (Intra/Intergroup) {#tissue_pca_2}

## Intragroup Tissue PCA Plot

Intragroup Tissue PCA Plot will be assessed by the average Euclidean
distance to centroid of each tissue sample. This will be done by first
measuring centroid of each tissue group in PCA score plot and
calculating the Euclidean Distance of individal tissue samples to their
corresponding centroid then average it.

::: {style="text-align: center;"}
\<img src="image/Intragroup_Distance.png" alt="Intragrou_Distance.png"
:::
::::

::: {#tissue_pca3 .cell .r}
```{r}
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(cowplot)
library(gridExtra)
library(dplyr)

# Set plot dimensions
options(repr.plot.width = 10, repr.plot.height = 10)

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data %>%
  filter(Type %in% sample_set_2)

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate distances between each sample and its corresponding centroid within each tissue type
tissue_pca_data_with_centroids <- left_join(tissue_pca_data, centroids, by = "Type")
tissue_pca_data_with_centroids <- tissue_pca_data_with_centroids %>%
  mutate(distance_to_centroid = sqrt((PC1 - Centroid_PC1)^2 + (PC2 - Centroid_PC2)^2))

# Calculate average distance within each tissue type
tissue_avg_distances <- tissue_pca_data_with_centroids %>%
  group_by(Type) %>%
  summarize(avg_distance_within_tissue = round(mean(distance_to_centroid), 3)) %>%
  rename('Average Distance Within Tissue' = avg_distance_within_tissue)

# Create intragroup pca plot with distance lines for visual validation
tissue_intra_plot <- ggplot(tissue_pca_data_with_centroids, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_segment(aes(x = PC1, y = PC2, xend = Centroid_PC1, yend = Centroid_PC2), linetype = "dashed") +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +
  labs(title = "No Normalization Tissue PCA (Intragroup)",
       x = paste("PC1 - ", round(batch_pca$sdev[1]^2 / sum(batch_pca$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca$sdev[2]^2 / sum(batch_pca$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create table plot
table_plot <- tableGrob(tissue_avg_distances, rows = NULL)

# Arrange PCA plot and table plot
combined_plot_intra <- grid.arrange(tissue_intra_plot, table_plot, ncol = 1, heights = c(3, 1))
cat("\033[1mTissue PCA plot (Intragroup) No normalization dataset. The triangles represent centroids for each tissue and average within tissue based on distance from each centroid.\033[0m\n")

# Print the combined plot
print(combined_plot_intra)
```
:::

::: {#tissue_pca4 .cell .r}
```{r}
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(gridExtra)
library(dplyr)

# Set plot dimensions
options(repr.plot.width = 10, repr.plot.height = 10)

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_TIC %>%
  filter(Type %in% sample_set_2)

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate distances between each sample and its corresponding centroid within each tissue type
tissue_pca_data_with_centroids <- left_join(tissue_pca_data, centroids, by = "Type")
tissue_pca_data_with_centroids <- tissue_pca_data_with_centroids %>%
  mutate(distance_to_centroid = sqrt((PC1 - Centroid_PC1)^2 + (PC2 - Centroid_PC2)^2))

# Calculate average distance within each tissue type
tissue_avg_distances_TIC <- tissue_pca_data_with_centroids %>%
  group_by(Type) %>%
  summarize(avg_distance_within_tissue = round(mean(distance_to_centroid), 3)) %>%
  rename('Average Distance Within Tissue' = avg_distance_within_tissue)

# Create intragroup PCA plot with distance lines for visual validation
tissue_intra_plot_TIC <- ggplot(tissue_pca_data_with_centroids, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_segment(aes(x = PC1, y = PC2, xend = Centroid_PC1, yend = Centroid_PC2), linetype = "dashed") +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +
  labs(title = "TIC Normalization Tissue PCA (Intragroup)",
       x = paste("PC1 - ", round(batch_pca_TIC$sdev[1]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_TIC$sdev[2]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create table plot
table_plot <- tableGrob(tissue_avg_distances_TIC, rows = NULL)

# Arrange PCA plot and table plot
combined_plot_TIC_intra <- grid.arrange(tissue_intra_plot_TIC, table_plot, ncol = 1, heights = c(3, 1))
cat("\033[1mTissue PCA plot (Intragroup) TIC normalization dataset. The triangles represents centroids for each tissue and average within tissue based on distance from each centroids.\033[0m\n")

# Print the combined plot
print(combined_plot_TIC_intra)
```
:::

::: {#tissue_pca5 .cell .r}
```{r}
## Overview PCA plot ##
library(gridExtra)
combined_plots <- grid.arrange(combined_plot_intra,
                               combined_plot_TIC_intra,
                               nrow = 1)
print(combined_plots)
```
:::

:::: {#tissue_pca6 .cell .r}
## Intergroup Tissue PCA Plot

Intergroup tissue is measured by a pairwise distance calculation between
each centroid of tissue groups. It will first measure the centroid of
each tissue group in PCA score plot and will create all possible unique
pairs of tissue types and for each pair of tissue types, the pairwise
Distance between their centroids is calculated. This will represent
between-cluster heterogeneity thus the greater the distance, the better
the data quality. It is measured like the equation below.

::: {style="text-align: center;"}
<img src="image/Inter_distance.png" alt="Inter_distance.png" style="width:50%;"/>
:::
::::

::: {.cell .r}
```{r}
## Intergroup Tissue PCA Plot ##
# No Norm #
library(ggplot2)
library(dplyr)
library(ggrepel)
library(gridExtra)

options(repr.plot.width = 10, repr.plot.height = 10)  # Adjust width and height as desired

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data %>%
  filter(Type %in% sample_set_2)
      
# Check if tissue_pca_data is not empty
if (nrow(tissue_pca_data) == 0) {
  stop("No tissue samples found in the given sample_set.")
}

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2)) # only obtaining PC1 and PC2

# Calculate intergroup distance (pairwise distances) # 
tissue_combinations <- combn(unique(centroids$Type), 2, simplify = TRUE)

# Initialize an empty data frame to store pairwise distances
centroid_distances_df <- data.frame(Tissue1 = character(), Tissue2 = character(), Pair_Distance = numeric())

# Iterate over each pair of tissue combinations
for (i in 1:ncol(tissue_combinations)) {
  tissue_pair <- tissue_combinations[, i]
  centroid1 <- centroids %>% filter(Type == tissue_pair[1])
  centroid2 <- centroids %>% filter(Type == tissue_pair[2])
  distance <- sqrt((centroid1$Centroid_PC1 - centroid2$Centroid_PC1)^2 + (centroid1$Centroid_PC2 - centroid2$Centroid_PC2)^2)
  centroid_distances_df <- rbind(centroid_distances_df, data.frame(Tissue1 = tissue_pair[1], Tissue2 = tissue_pair[2], Pair_Distance = round(distance, 3)))
}

# Create the Tissue PCA Plot
tissue_intergroup_plot <- ggplot(tissue_pca_data, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +  
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +  
  labs(title = "No Normalization Tissue PCA (Intergroup)",
       x = paste("PC1 - ", round(batch_pca$sdev[1]^2 / sum(batch_pca$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca$sdev[2]^2 / sum(batch_pca$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create a table grob for centroid distances
centroid_table <- tableGrob(centroid_distances_df, rows = NULL)

# Arrange plots and table vertically
combined_plot_inter <- grid.arrange(tissue_intergroup_plot, centroid_table, ncol = 1, heights = c(3, 1))
cat("\033[1mTissue PCA plot (Intergroup) No normalization dataset. The triangles represent centroids for each tissue and pair average of tissue based on distance from each centroid.\033[0m\n")

print(combined_plot_inter)
```
:::

::: {#tissue_pca_inter .cell .markdown}
```{r}
## Intergroup Tissue PCA Plot ##
# TIC norm #
library(ggplot2)
library(dplyr)
library(ggrepel)
library(gridExtra)

options(repr.plot.width = 10, repr.plot.height = 10)  # Adjust width and height as desired

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_TIC %>%
  filter(Type %in% sample_set_2)

# Check if tissue_pca_data is not empty
if (nrow(tissue_pca_data) == 0) {
  stop("No tissue samples found in the given sample_set.")
}

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2)) # obtains only PC1 and PC2

# Calculate intergroup distance (pairwise distances)
tissue_combinations <- combn(unique(centroids$Type), 2, simplify = TRUE)

# Initialize an empty data frame to store pairwise distances
centroid_distances_df_TIC <- data.frame(Tissue1 = character(), Tissue2 = character(), Pair_Distance = numeric())

# Iterate over each pair of tissue combinations
for (i in 1:ncol(tissue_combinations)) {
  tissue_pair <- tissue_combinations[, i]
  centroid1 <- centroids %>% filter(Type == tissue_pair[1])
  centroid2 <- centroids %>% filter(Type == tissue_pair[2])
  distance <- sqrt((centroid1$Centroid_PC1 - centroid2$Centroid_PC1)^2 + (centroid1$Centroid_PC2 - centroid2$Centroid_PC2)^2)
  centroid_distances_df_TIC <- rbind(centroid_distances_df_TIC, data.frame(Tissue1 = tissue_pair[1], Tissue2 = tissue_pair[2], Pair_Distance = round(distance, 3)))
}

# Create the tissue plot
tissue_intergroup_plot_TIC <- ggplot(tissue_pca_data, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +  
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +  
  labs(title = "TIC Normalization Tissue PCA (Intergroup)",
       x = paste("PC1 - ", round(batch_pca_TIC$sdev[1]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_TIC$sdev[2]^2 / sum(batch_pca_TIC$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create a table grob for centroid distances
centroid_table_TIC <- tableGrob(centroid_distances_df_TIC, rows = NULL)

# Arrange plots and table vertically
combined_plot_TIC_inter <- grid.arrange(tissue_intergroup_plot_TIC, centroid_table_TIC, ncol = 1, heights = c(3, 1))
cat("\033[1mTissue PCA plot (Intergroup) TIC normalization dataset. The triangles represent centroids for each tissue and pair average of tissue based on distance from each centroid.\033[0m\n")

print(combined_plot_TIC_inter)
```
:::

::: {.cell .markdown}
```{r}
## Overview PCA plot ##
library(gridExtra)
combined_plots <- grid.arrange(combined_plot_inter,
                               combined_plot_TIC_inter,
                               nrow = 1,
                               heights = c(1,1)
                               )
print(combined_plots)
```
:::

::: {#correction .cell .markdown}
## Correction {#correction_2}

Now, we will correct the batch effect using these packages.

1.  [Combat](#combat_2)
2.  [WaveICA](#waveica_2)
3.  [NormAE (You need to run externally, but you can obtain a set up
    dataset used for external code](#normae_2)
    <https://github.com/luyiyun/NormAE>

For more Batch Effect Correction try this site:
<https://www.metaboanalyst.ca/MetaboAnalyst/upload/BatchUpload.xhtml>
:::

:::: {#choosingdata .cell .r}
::: {.cell .markdown}
## Choosing the Dataset
:::

```{r}
# Get user input for normalization type
normalization_type <- readline(prompt = "Please choose a dataset to correct. Enter 'no' for No Normalization or 'tic' for TIC Normalization: ")

# Assign the appropriate data frame based on user input
if (tolower(normalization_type) == "no") {
  combined_batch_data_df_corr <- combined_batch_data_df_2
  combined_batch_info_data_df_corr <- combined_batch_info_data_2
    
} else if (tolower(normalization_type) == "tic") {
  combined_batch_data_df_corr <- combined_batch_data_df_TIC_2
  combined_batch_info_data_df_corr <- combined_batch_info_data_TIC_2
    
} else {
  stop("Invalid input. Please enter 'no' or 'tic'.")
}
```
::::

:::{checkingdataset .cell .r}

```{r}
# checking dataset
check_dataset <- readline(prompt = "Would you like to check the dataset? (yes/no): ")

# print the dataset based on user input
if (tolower(check_dataset) == "yes") {
  print(head(combined_batch_data_df_corr))
} else if (tolower(check_dataset) == "no") {
  cat("Dataset will not be printed.\n")
} else {
  cat("Invalid input. Dataset will not be printed.\n")
}
```

:::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: {#combat .cell .r}
::: {.cell .markdown}
## 1. Combat {#combat_2}

```{r}
# Installing sva package 3 ways: normal, remote, bioconductor

install_sva <- function() {
  # Check if 'sva' is already installed
  if (!requireNamespace("sva", quietly = TRUE)) {
    
    # Install sva
    install.packages("sva")

    # Check if remotes is installed and install if not
    if (!requireNamespace("remotes", quietly = TRUE)) {
      install.packages("remotes")
    }
    
    # Try installing sva from GitHub
    tryCatch({
      remotes::install_github("jtleek/sva")
      cat("\033[1m'sva' installed successfully from GitHub.\033[0m\n")
    }, error = function(e) {
      cat("\033[1mFailed to install 'sva' from GitHub. Attempting to install from Bioconductor...\033[0m\n")
      
      # Check if BiocManager is installed and install if not
      if (!requireNamespace("BiocManager", quietly = TRUE)) {
        install.packages("BiocManager")
      }
      
      # Install from Bioconductor
      tryCatch({
        BiocManager::install("sva")
        cat("\033[1m'sva' installed successfully from Bioconductor.\033[0m\n")
      }, error = function(e) {
        cat("\033[1mFailed to install 'sva' from Bioconductor as well.\033[0m\n")
      })
    })
    
  } else {
    cat("\033[1m'sva' is already installed.\033[0m\n")
  }
}

# Call the function to install sva
install_sva()
```
:::

::: {.cell .r}
```{r}
## Combat ## 
# load the packages
library(sva)

# obtaining peak_data
row_names <- combined_batch_data_df_corr[, 1] 
peak_data <- as.data.frame(combined_batch_data_df_corr[,-(1:3)]) 
rownames(peak_data) <- row_names
peak_data_matrix <- as.matrix(peak_data)
peak_data_matrix <- apply(peak_data_matrix, 2, as.numeric)
rownames(peak_data_matrix) <- row_names

# obtaining batch_info
batch_data <- as.data.frame(t(combined_batch_info_data_df_corr[,-(1)])) 
batch_info_values <- as.vector(unlist(batch_data["batch", , drop = FALSE]))
batch_info_interday <- as.numeric(batch_info_values)
#print(length(batch_info_interday))

# running combat
combat_result_interday <- ComBat(dat = peak_data_matrix, batch = batch_info_interday)

combat_result_interday_df <- as.data.frame(combat_result_interday)

# save dataset as csv file
write.csv(combat_result_interday,
          file = "Dataset/combat_interday_corrected_data.csv",
          row.names = TRUE)
cat("\033[1mCombat is successfully completed. Check the result in dataset folder. Also, result has been saved as combat_result_interday variable\033[0m\n")
```
:::

:::: {#waveica .cell .r}
::: {.cell .markdown}
## 2. WaveICA {#waveica_2}
:::

```{r}
# Installing WaveICA in 3 ways: normal, remote, bioconductor
# Try installing using remotes (GitHub)
install_waveica <- function() {
  if (!requireNamespace("WaveICA", quietly = TRUE)) {
    install.packages("WaveICA")
    # Check if remotes is installed and install if not
    if (!requireNamespace("remotes", quietly = TRUE)) {
      install.packages("remotes")
    }
    
    # Attempt installation using remotes (GitHub)
    tryCatch({
      remotes::install_github("dengkuistat/WaveICA", host = "https://api.github.com", dependencies = TRUE)
      if (requireNamespace("WaveICA", quietly = TRUE)) {
        cat("\033[1mWaveICA is successfully installed using remotes.\033[0m\n")
      }
    }, error = function(e) {
      cat("\033[1mRemotes installation failed, trying Bioconductor method...\033[0m\n")
      
      # Check if BiocManager is installed and install if not
      if (!requireNamespace("BiocManager", quietly = TRUE)) {
        install.packages("BiocManager")
      }
      
      # Attempt installation using BiocManager if remotes fails
      tryCatch({
        BiocManager::install("WaveICA")
        if (requireNamespace("WaveICA", quietly = TRUE)) {
          cat("\033[1mWaveICA is successfully installed using Bioconductor.\033[0m\n")
        }
      }, error = function(e) {
        cat("\033[1mBioconductor installation failed.\033[0m\n")
      })
    })
  } else {
    cat("\033[1m'WaveICA' is already installed.\033[0m\n")
  }

  # Final success message if the package is installed
  if (requireNamespace("WaveICA", quietly = TRUE)) {
    cat("\033[1mWaveICA is successfully installed.\033[0m\n")
  } else {
    cat("WaveICA installation failed after all attempts.\n")
  }
}

# Call the function to install WaveICA
install_waveica()
```
::::

::: {.cell .r}
```{r}
## WaveICA ##
# load packages
library(WaveICA)

# obtaining peak_data
row_names <- combined_batch_data_df_corr[, 1]
peak_data <- as.data.frame(combined_batch_data_df_corr[,-(1:3)])
rownames(peak_data) <- row_names
peak_data_trans <- as.data.frame(t(peak_data))
peak_data_trans <- sapply(peak_data_trans, as.numeric)
rownames(peak_data_trans) <- colnames(peak_data)

# Convert peak_data_trans to a matrix
peak_data_matrix <- as.matrix(peak_data_trans)

# Keep the row names from peak_data_trans in the matrix
rownames(peak_data_matrix) <- rownames(peak_data_trans)

# obtaining batch_info
batch_data <- as.data.frame(t(combined_batch_info_data_df_corr[,-(1)]))
batch_info_values <- as.vector(unlist(batch_data["batch", , drop = FALSE]))
batch_info_interday <- as.numeric(batch_info_values)
#print(length(batch_info_interday)) # 126 samples

# running waveICA
waveica_result_interday_matrix <- WaveICA(peak_data_matrix, batch = batch_info_interday, group = NULL)
waveica_result_interday <- as.data.frame(waveica_result_interday_matrix[["data_wave"]]) # 126 obs of 120 variables

# save dataset as csv file
write.csv(waveica_result_interday,
          file = "Dataset/waveica_interday_corrected_data.csv",
          row.names = TRUE)
cat("\033[1mWaveICA is successfully completed. Check the result in dataset folder. Also, result has been saved as waveica_result_interday variable\033[0m\n")
```
:::

:::: {#normae.cell .r}
::: {#normae .cell .markdown}
## 3. NormAE {#normae_2}

**(This will only prepare dataset, you will need to run NormAE
externally)**
:::

```{r}
## NormAE ##
# load libraries
library(dplyr)

# dataset preparation
# convert combined_batch_data_df into txt file
write.table(combined_batch_data_df_corr, 
            file = "Input/metabolomics_data_normae.txt", 
            sep = ",", 
            quote = FALSE, 
            row.names = FALSE)

# add column for group
batch_info_2_norm <- batch_info_2 %>%
  mutate(group = 1)

# add a new column called "class"
batch_info_2_norm <- batch_info_2_norm %>%
  mutate(class = ifelse(grepl(paste(sample_set_2, collapse = "|"), sample.name), "Subject", "QC"))

# move the first three columns
combined_batch_data_df_norm <- combined_batch_data_df_corr[, -(1:3)]

# check if sample names match column names
names_match <- all(batch_info_2_norm$sample.name %in% colnames(combined_batch_data_df_norm))

if (names_match) {
  print("The sample names in batch_info match the column names of combined_batch_data_df.")
} else {
  print("The sample names in batch_info do not match the column names of combined_batch_data_df. Thus, have adjusted accordingly")
  
  # Extract column names from combined_batch_data_df
  col_names_combined <- colnames(combined_batch_data_df_norm)
  
  # Replace sample names in batch_info with column names from combined_batch_data_df
  batch_info_2_norm$sample.name <- col_names_combined
}

# make it txt file
# we need two txt file one batch_info and one normae
write.table(batch_info_2_norm,
            file = "Input/batch_info_normae.txt",
            sep = ",",
            row.names = FALSE,
            quote = FALSE)
cat("\033[1mPlease go to https://github.com/luyiyun/NormAE and run NormAE and put Rec_nobe.csv and Ys.csv into dataset folder. Then, run the below cell \033[0m\n")

# After obtaining two txt file follow these steps to run NormAE
# Step 1: Go to https://github.com/luyiyun/NormAE
# Step 2: Click code and download zip
# Step 3: Open zip file (vs code/pycharm/python)
# Step 4: Check if dataset works with using dataset script (at the last you can change file path into normae and batch_info file path
# Step 5: If dataset works, open command (command prompt) and run underneath example code
# Step 6: python -m visdom.server (command to open visdom)
# Step 7: python main.py --task train --meta_data data\data12\norm.txt --device CPU --sample_data data\data12\batch.txt --visdom_port 8097 --save data\Training12 (command to train, change the file path)
# Step 8: python main.py --task remove --meta_data data\data12\norm.txt --sample_data data\data12\batch.txt --device CPU --visdom_port 8097 --save data\Training12 --load data/Training12/models.pth (command to correct batch, change the file path)
# Step 9: put on two files after NormAE (Rec_nobe.csv and Ys.csv) into dataset folder
```
::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: {#settingnormaedataset .cell .markdown}
# Here requires yours input/changes

**Please enter a correct csv file path accordingly whether it is no
normalization or TIC normalization dataset after uploading the NormAE
corrected dataset into dataset folder. If you have uploaded in a correct
folder, you can put file path like "dataset/name_of_your_file.csv".**

::: {#settingnormaedataset2 .cell .r}
```{r}
## extract normae data from dataset ## 
normae_result_interday <- read.csv("Dataset/Rec_nobe_no_norm.csv", ## change file name accordingly to your Rec_nobe file ##
                                  header = TRUE,
                                  stringsAsFactors = FALSE,
                                  row.names = 1)

batch_info_normae <- read.csv("Dataset/Ys_no_norm.csv", ## change file name accordingly to your Ys file ##
                            header = TRUE,
                            stringsAsFactors = FALSE)

cat("\033[1mData preparation of NormAE is successfully completed. Check the result in dataset file. Also, result has been saved as normae_result_interday variable. \033[0m\n")
```
:::

::: {.cell .markdown}
##Correction_Results{#correction_results_2}

1.  [QCS_RSD](#corr_qcs_rsd_2)
2.  [QCS_Intensity_Plot](#corr_qcs_intensity_2)
3.  [QCS_Violin_Plot](#corr_qcs_violin_2)
4.  [PCA Plot](#corr_pca_2)
5.  [QCS_PCA_Plot](#corr_qcs_pca_2)
6.  [Tissue_RSD](#corr_tissue_rsd_2)
7.  [Tissue PCA Plot (Intra/Intergroup)](#corr_tissue_pca_2)
:::

::: {#corr_QCS_rsd .cell .markdown}
## 1. QCS RSD {#corr_qcs_rsd_2}
:::

::: {#corr_QCS_rsd2 .cell .r}
```{r}
## Run these functions first ##

# 1: Function to extract tissue samples away
extract_qcs_data <- function(dataset, sample_set) {
  pattern <- paste(sample_set, collapse = "|")
  
  # Extract tissue rows
  tissue_rows <- grep(pattern, rownames(dataset))
  
  # Subset dataframe to exclude tissue rows
  qcs_data <- dataset[-tissue_rows, , drop = FALSE]
  
  return(qcs_data)
}

# 2: Function to calculate RSD
calculate_rsd <- function(data) {
  sd_value <- sd(data)
  mean_value <- mean(data)
  rsd <- (sd_value / mean_value) * 100
  return(rsd)
}

# 3: Function to calculate RSD for each batch
calculate_batch_rsd <- function(data, mz_value) {
  # Convert mz_value to character
  mz_value <- as.character(mz_value)
  # Convert column to numeric
  data[[mz_value]] <- as.numeric(data[[mz_value]], na.rm = TRUE)
  # Calculate RSD for each batch, rounding to two decimal places
  batch_rsd <- aggregate(data[[mz_value]],
                         by = list(batch = data$batch),
                         FUN = function(x) round(calculate_rsd(x), 3))
  # Rename columns
  colnames(batch_rsd) <- c("Batch", "RSD")
  # Calculate interday RSD, rounding to two decimal places
  interday_rsd <- round(calculate_rsd(data[[mz_value]]), 3)
  # Create a new row for interday RSD
  interday_row <- data.frame(Batch = "Interday", RSD = interday_rsd)
  # Combine batch_rsd with interday_rsd
  batch_rsd <- rbind(batch_rsd, interday_row)
  # Replace all RSD values with percentage symbol
  batch_rsd$RSD <- paste0(batch_rsd$RSD, "%")
  # Replace batch labels with "Intraday 1", "Intraday 2", "Intraday 3"
  batch_rsd$Batch <- ifelse(batch_rsd$Batch == "Interday", "Interday", paste0("Intraday ", batch_rsd$Batch))
  return(batch_rsd)
}
```
:::

::: {#corr_QCS_rsd3 .cell .r}
```{r}
## QCS RSD Table ## 
# Combat #
data <- combat_result_interday_df

row_names <- rownames(data)
batch_info_norm <- batch_info_2

injection_order_norm <- batch_info_norm$injection.order
batch_norm <- batch_info_norm$batch

# add injection_order and batch_info
new_data <- rbind(injection_order_norm, batch_norm, data) 
new_row_names <- c("injection_order", "batch", row_names)
rownames(new_data) <- new_row_names

# Transpose the data
transposed_data <- as.data.frame(t(new_data))

# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(transposed_data, sample_set_2)
batch_info_columns <- qcs_batch_info_data[, 1:2, drop = FALSE]

# extract qcs data
QCS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == QCS_mz_value_2, drop = FALSE]
QCS_data_combat <- cbind(batch_info_columns, QCS_peak_data)

IS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == IS_mz_value_2, drop = FALSE]
IS_data_combat <- cbind(batch_info_columns, IS_peak_data)

# usage:
cat("\033[1mRSD for Combat:\033[0m\n")                                   
rsd_QCS_combat <- calculate_batch_rsd(QCS_data_combat, QCS_mz_value_2)
cat("m/z value:", QCS_mz_value_2, "\n")
print(rsd_QCS_combat)

rsd_IS_combat <- calculate_batch_rsd(IS_data_combat, IS_mz_value_2)
cat("m/z value:", IS_mz_value_2, "\n")
print(rsd_IS_combat)
```
:::

::: {.cell .r}
```{r}
## QCS RSD Table ##
# WaveICA #
data <- as.data.frame(t(waveica_result_interday)) 

# or if you are reading directly from file 
#data <- read.csv("dataset_2/waveica_interday_corrected_data.csv", # check file path 
                 #header = TRUE,
                 #stringsAsFactors = FALSE,
                 #row.names = 1) 
#data <- as.data.frame(t(data))

row_names <- rownames(data)
batch_info_norm <- batch_info_2

injection_order_norm <- batch_info_norm$injection.order
batch_norm <- batch_info_norm$batch

# add injection_order and batch_info
new_data <- rbind(injection_order_norm, batch_norm, data)
new_row_names <- c("injection_order", "batch", row_names)
rownames(new_data) <- new_row_names

# Transpose the data
transposed_data <- as.data.frame(t(new_data))

# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(transposed_data, sample_set_2)
batch_info_columns <- qcs_batch_info_data[, 1:2, drop = FALSE]

# extract qcs data
QCS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == QCS_mz_value_2, drop = FALSE]
QCS_data_wave <- cbind(batch_info_columns, QCS_peak_data)
IS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == IS_mz_value_2, drop = FALSE]
IS_data_wave <- cbind(batch_info_columns, IS_peak_data)

# usage:
cat("\033[1mRSD for WaveICA:\033[0m\n")                                   
rsd_QCS_wave <- calculate_batch_rsd(QCS_data_wave, QCS_mz_value_2)
cat("m/z value:", QCS_mz_value_2, "\n")
print(rsd_QCS_wave)

rsd_IS_wave <- calculate_batch_rsd(IS_data_wave, IS_mz_value_2)
cat("m/z value:", IS_mz_value_2, "\n")
print(rsd_IS_wave)
```
:::

::: {.cell .r}
```{r}
## QCS RSD Table ## 
# NormAE #
data <- normae_result_interday

row_names <- rownames(data)
batch_info_norm <- batch_info_normae

injection_order_norm <- batch_info_norm$injection.order
batch_norm <- batch_info_norm$batch

# add injection_order and batch_info
new_data <- rbind(injection_order_norm, batch_norm, data)
new_row_names <- c("injection_order", "batch", row_names)
rownames(new_data) <- new_row_names

# Transpose the data
transposed_data <- as.data.frame(t(new_data))

# get rid of tissue samples
qcs_batch_info_data <- extract_qcs_data(transposed_data, sample_set_2)
batch_info_columns <- qcs_batch_info_data[, 1:2, drop = FALSE]

# extract qcs data
QCS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == QCS_mz_value_2, drop = FALSE]
QCS_data_norm <- cbind(batch_info_columns, QCS_peak_data)
QCS_data_norm$batch <- QCS_data_norm$batch + 1

IS_peak_data <- qcs_batch_info_data[,colnames(qcs_batch_info_data) == IS_mz_value_2, drop = FALSE]
IS_data_norm <- cbind(batch_info_columns, IS_peak_data)
IS_data_norm$batch <- IS_data_norm$batch + 1

# usage:
cat("\033[1mRSD for NormAE:\033[0m\n")                    
rsd_QCS_norm <- calculate_batch_rsd(QCS_data_norm, QCS_mz_value_2)
cat("m/z value:", QCS_mz_value_2, "\n")
print(rsd_QCS_norm)

rsd_IS_norm <- calculate_batch_rsd(IS_data_norm, IS_mz_value_2)
cat("m/z value:", IS_mz_value_2, "\n")
print(rsd_IS_norm)
```
:::

::: {#corr_QCS_rsd4 .cell .r}
```{r}
## RSD Overview Table ##
library(kableExtra)
library(htmltools)
library(IRdisplay)

# propranolol #
overview_table_QCS <- data.frame(
  Row_Names = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
  Combat_RSD = rsd_QCS_combat[2],
  WaveICA_RSD = rsd_QCS_wave[2],
  NormAE_RSD = rsd_QCS_norm[2]
)

# Set the column names
colnames(overview_table_QCS) <- c(paste("m/z value:", QCS_mz_value_2), "Combat", "WaveICA", "NormAE")

# Displaying overview RSD table
display_rsd_table_QCS <- kable(overview_table_QCS, format = "html", row.names = FALSE) %>%
  kable_styling(full_width = FALSE)

# Add table name
display_rsd_table_QCS <- paste("<h2 style='text-align: center;'>Overview RSD Table QCS</h2>", 
                               as.character(display_rsd_table_QCS))

# Save HTML table to a file
print(display_rsd_table_QCS)

# D7-propranolol # 
overview_table_IS <- data.frame(
  Row_Names = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
  Combat_RSD = rsd_IS_combat[2],
  WaveICA_RSD = rsd_IS_wave[2],
  NormAE_RSD = rsd_IS_norm[2]
)

# Set the column names
colnames(overview_table_IS) <- c(paste("m/z value:", IS_mz_value_2), "Combat", "WaveICA", "NormAE")


# Displaying overview RSD table
display_rsd_table_IS <- kable(overview_table_IS, format = "html", row.names = FALSE) %>%
  kable_styling(full_width = FALSE)

# Add table name
display_rsd_table_IS <- paste("<h2 style='text-align: center;'>Overview RSD Table Internal Standard</h2>", 
                               as.character(display_rsd_table_IS))

# Save HTML table to a file
print(display_rsd_table_IS)
```
:::

::: {#corr_intensity .cell .markdown}
## 2. Intensity Plot {@intensity_plot_2}
:::

::: {.cell .r}
```{r}
## Intensity Plot (Intensity vs Measurement Order ##

# Combat #
# reading combat dataset
combined_batch_info_data_combat <- combat_result_interday_df

batch_info <- batch_info_2
                       
combined_batch_info_data_combat <- as.data.frame(t(combined_batch_info_data_combat)) 
combined_batch_info_data_combat <- cbind(batch_info[,-1], combined_batch_info_data_combat)  

# extract qcs data (get rid of tissue samples)
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_combat, sample_set_2)
qcs_batch_info_data_ordered <- qcs_batch_info_data[order(qcs_batch_info_data$batch), ] # ordering by its batch
batch <- qcs_batch_info_data_ordered$batch # adding batch column

# ordering by s_value
row_names_qcs <- rownames(qcs_batch_info_data_ordered)
s_values <- as.numeric(sub(".*S(\\d+).*", "\\1", row_names_qcs))

qcs_batch_info_data_ordered$S <- s_values
qcs_batch_info_data_ordered <- qcs_batch_info_data_ordered[order(qcs_batch_info_data_ordered$batch, qcs_batch_info_data_ordered$S), ]

# extract propranolol only
QCS_intensity <- qcs_batch_info_data_ordered[,colnames(qcs_batch_info_data_ordered) == QCS_mz_value_2, drop = FALSE]
QCS_intensity_values <- as.numeric(unlist(QCS_intensity))
QCS_intensity <- scale(QCS_intensity_values) # scaling intensity plot

# add measurement order
qcs_batch_info_data_ordered$measurement_order <- seq_len(nrow(qcs_batch_info_data_ordered))

# make a data frame for intensity plot
plot_data_scaled <- data.frame(
  Measurement_order = qcs_batch_info_data_ordered$measurement_order,
  Batch = qcs_batch_info_data_ordered$batch,
  Intensity = QCS_intensity
)

# add rownames to plot_data_scaled
rownames(plot_data_scaled) <- rownames(qcs_batch_info_data_ordered)

mean_intensity <- mean(plot_data_scaled$Intensity)
sd_intensity <- sd(plot_data_scaled$Intensity)
batch_unique <- unique(plot_data_scaled$Batch)
options(repr.plot.width = 10, repr.plot.height = 6) # adjust the intensity plot format as you desired

# intensity plot with mean and standard deviation lines
library(ggplot2)
intensity_plot_combat <- ggplot(plot_data_scaled, aes(x = Measurement_order, y = Intensity, color = factor(Batch))) +
  geom_point(size = 5) +  
  geom_line(aes(group = Batch), alpha = 0.5) + 
  geom_hline(yintercept = mean_intensity, linetype = "dotted", color = "red", linewidth = 1) +  
  geom_hline(yintercept = mean_intensity + sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean + standard deviation
  geom_hline(yintercept = mean_intensity - sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean - standard deviation
  labs(x = "Measurement_order", y = "Scaled Intensity", color = "Batch") + 
  scale_x_continuous(breaks = seq(5, max(plot_data_scaled$Measurement_order), by = 5)) + 
  scale_color_manual(values = c("1" = "red", "2" = "green", "3" = "blue")) +  
  ggtitle("Combat") +
  theme(
    plot.title = element_text(size = 40, hjust = 0.5, face = "bold"), 
    axis.title.x = element_text(size = 25, face = "bold"), 
    axis.title.y = element_text(size = 25, face = "bold"),  
    axis.text.x = element_text(size = 15, face = "bold"),  
    axis.text.y = element_text(size = 20, face = "bold")  
  )
print(intensity_plot_combat)

# WaveICA #
# reading waveica dataset
combined_batch_info_data_wave <- as.data.frame(t(waveica_result_interday))

batch_info <- batch_info_2
                       
combined_batch_info_data_wave <- as.data.frame(t(combined_batch_info_data_wave)) 
combined_batch_info_data_wave <- cbind(batch_info[,-1], combined_batch_info_data_wave)  

# extract qcs data (get rid of tissue sample)
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_wave, sample_set_2)
qcs_batch_info_data_ordered <- qcs_batch_info_data[order(qcs_batch_info_data$batch), ] 
batch <- qcs_batch_info_data_ordered$batch 

# ordering by batch then s_value
row_names_qcs <- rownames(qcs_batch_info_data_ordered)
s_values <- as.numeric(sub(".*S(\\d+).*", "\\1", row_names_qcs))

qcs_batch_info_data_ordered$S <- s_values
qcs_batch_info_data_ordered <- qcs_batch_info_data_ordered[order(qcs_batch_info_data_ordered$batch, qcs_batch_info_data_ordered$S), ]

# extract propranolol intensity
QCS_intensity <- qcs_batch_info_data_ordered[,colnames(qcs_batch_info_data_ordered) == QCS_mz_value_2, drop = FALSE] # 126 obs 1 variable
QCS_intensity_values <- as.numeric(unlist(QCS_intensity))
QCS_intensity <- scale(QCS_intensity_values)

# add measurement_order
qcs_batch_info_data_ordered$measurement_order <- seq_len(nrow(qcs_batch_info_data_ordered))

# make data frame for intensity plot
plot_data_scaled <- data.frame(
  Measurement_order = qcs_batch_info_data_ordered$measurement_order,
  Batch = qcs_batch_info_data_ordered$batch,
  Intensity = QCS_intensity
)

# add rownames to plot_data_scaled
rownames(plot_data_scaled) <- rownames(qcs_batch_info_data_ordered)

mean_intensity <- mean(plot_data_scaled$Intensity)
sd_intensity <- sd(plot_data_scaled$Intensity)
batch_unique <- unique(plot_data_scaled$Batch)
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired

# intensity plot with mean and standard deviation lines
library(ggplot2)
intensity_plot_wave <- ggplot(plot_data_scaled, aes(x = Measurement_order, y = Intensity, color = factor(Batch))) +
  geom_point(size = 5) + 
  geom_line(aes(group = Batch), alpha = 0.5) + 
  geom_hline(yintercept = mean_intensity, linetype = "dotted", color = "red", linewidth = 1) +  # Add black dotted line for mean
  geom_hline(yintercept = mean_intensity + sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean + standard deviation
  geom_hline(yintercept = mean_intensity - sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean - standard deviation
  labs(x = "Measurement_order", y = "Scaled Intensity", color = "Batch") + 
  scale_x_continuous(breaks = seq(5, max(plot_data_scaled$Measurement_order), by = 5)) + 
  scale_color_manual(values = c("1" = "red", "2" = "green", "3" = "blue")) +  
  ggtitle("WaveICA") +
  theme(
    plot.title = element_text(size = 40, hjust = 0.5, face = "bold"),  
    axis.title.x = element_text(size = 25, face = "bold"),  
    axis.title.y = element_text(size = 25, face = "bold"),  
    axis.text.x = element_text(size = 15, face = "bold"),  
    axis.text.y = element_text(size = 20, face = "bold") 
  )
print(intensity_plot_wave)

# NormAE #
combined_batch_info_data_norm <- normae_result_interday

batch_info <- batch_info_normae

batch_info$batch <- batch_info$batch + 1 # since normae makes batch go from 0 instead of 1

combined_batch_info_data_norm <- as.data.frame(t(combined_batch_info_data_norm)) 
combined_batch_info_data_norm <- cbind(batch_info[,(2:3)], combined_batch_info_data_norm)  

# extract qcs data onl (get rid of tissue sample)
qcs_batch_info_data <- extract_qcs_data(combined_batch_info_data_norm, sample_set_2)
qcs_batch_info_data_ordered <- qcs_batch_info_data[order(qcs_batch_info_data$batch), ] # ordering by batch
batch <- qcs_batch_info_data_ordered$batch # add batch column

# ordering by batch then s_value
row_names_qcs <- rownames(qcs_batch_info_data_ordered)
s_values <- as.numeric(sub(".*S(\\d+).*", "\\1", row_names_qcs))

qcs_batch_info_data_ordered$S <- s_values
qcs_batch_info_data_ordered <- qcs_batch_info_data_ordered[order(qcs_batch_info_data_ordered$batch, qcs_batch_info_data_ordered$S), ]

# extracting propranolol intensity
QCS_intensity <- qcs_batch_info_data_ordered[,colnames(qcs_batch_info_data_ordered) == QCS_mz_value_2, drop = FALSE]
QCS_intensity_values <- as.numeric(unlist(QCS_intensity))
QCS_intensity <- scale(QCS_intensity_values)

# add measurement_order
qcs_batch_info_data_ordered$measurement_order <- seq_len(nrow(qcs_batch_info_data_ordered))

# make data frame of intensity plot
plot_data_scaled <- data.frame(
  Measurement_order = qcs_batch_info_data_ordered$measurement_order,
  Batch = qcs_batch_info_data_ordered$batch,
  Intensity = QCS_intensity
)

# add rownames to plot_data_scaled
rownames(plot_data_scaled) <- rownames(qcs_batch_info_data_ordered)

#print(plot_data_scaled) # uncomment to check your intensity plot data frame

mean_intensity <- mean(plot_data_scaled$Intensity)
sd_intensity <- sd(plot_data_scaled$Intensity)
batch_unique <- unique(plot_data_scaled$Batch)
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as desired

# intensity plot with mean and standard deviation lines
library(ggplot2)
intensity_plot_norm <- ggplot(plot_data_scaled, aes(x = Measurement_order, y = Intensity, color = factor(Batch))) +
  geom_point(size = 5) +  # color = batch
  geom_line(aes(group = Batch), alpha = 0.5) + 
  geom_hline(yintercept = mean_intensity, linetype = "dotted", color = "red", linewidth = 1) + 
  geom_hline(yintercept = mean_intensity + sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean + standard deviation
  geom_hline(yintercept = mean_intensity - sd_intensity, linetype = "dotted", color = "black", linewidth = 1) +  # Add gray dotted line for mean - standard deviation
  labs(x = "Measurement_order", y = "Scaled Intensity", color = "Batch") + 
  scale_x_continuous(breaks = seq(5, max(plot_data_scaled$Measurement_order), by = 5)) +  
  scale_color_manual(values = c("1" = "red", "2" = "green", "3" = "blue")) +  
  ggtitle("NormAE") +
  theme(
    plot.title = element_text(size = 40, hjust = 0.5, face = "bold"), 
    axis.title.x = element_text(size = 25, face = "bold"), 
    axis.title.y = element_text(size = 25, face = "bold"), 
    axis.text.x = element_text(size = 15, face = "bold"),  
    axis.text.y = element_text(size = 20, face = "bold")  
  )
print(intensity_plot_norm)
```
:::

::: {#corr_intensity2 .cell .markdown}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Overview Intensity PLOT ##
library(gridExtra)
combined_intensity_plots <- grid.arrange(intensity_plot_combat,
                                         intensity_plot_wave,
                                         intensity_plot_norm,
                                         ncol = 1,
                                         heights = c(1,1,1))
print(combined_intensity_plots)
```
:::

::: {#corr_violinplot .cell .markdown}
## 3. Violin Plot {#corr_qcs_violin_2}
:::

::: {.cell .r}
```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(RColorBrewer)

# Function to scale data by its mean
scale_by_mean <- function(data_frame) {
  mean_value <- mean(data_frame$Value)
  sd_value <- sd(data_frame$Value)  
  data_frame <- data_frame %>%
    mutate(Value = (Value - mean_value) / sd_value) # Z-score normalization
  return(data_frame)
}

# Transform and prepare the dataset for Combat
QCS_data_trans_combat <- as.data.frame(t(QCS_data_combat))
QCS_data_trans_combat[] <- lapply(QCS_data_trans_combat, as.numeric)

# Extract slide number
slide_number_combat <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_combat))
slide_number_combat <- as.numeric(slide_number_combat)

# Create violin plot data frame for Combat
violin_data_combat <- data.frame(
  Slide = slide_number_combat,
  Batch = QCS_data_combat$batch,
  Value = unlist(QCS_data_trans_combat[3, ])
)

# Scale Combat data by its mean
violin_data_combat <- scale_by_mean(violin_data_combat)

# Define the colors for the first three batches
manual_colors <- c("1" = "Red", "2" = "Green", "3" = "Blue")

# Plot function to ensure consistent scaling
plot_violin <- function(data, title) {
  unique_batches <- unique(data$Batch)
  additional_batches <- setdiff(unique_batches, names(manual_colors))
  
  if (length(additional_batches) > 0) {
    additional_colors <- colorRampPalette(brewer.pal(9, "Set3"))(length(additional_batches))
    additional_colors <- setNames(additional_colors, additional_batches)
  } else {
    additional_colors <- c()
  }
  
  all_colors <- c(manual_colors, additional_colors)
  
  ggplot(data, aes(x = factor(Slide), y = Value, fill = factor(Batch))) +
    geom_violin(position = position_dodge(width = 0.5), trim = FALSE, width = 1) +
    stat_summary(fun = median, geom = "point", shape = 20, size = 3, color = "black") +
    geom_point(position = position_jitter(width = 0.1), alpha = 0.5) + 
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray", linewidth = 1) +
    scale_fill_manual(values = all_colors) +
    labs(x = "Slide Number", y = "Scaled Peak Data", title = title) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 25),
      axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 25),
      axis.title = element_text(face = "bold", size = 25),  
      plot.title = element_text(face = "bold", size = 35),  
      axis.text = element_text(size = 20)
    )
}

# Plot the data with each dataset scaled by its mean
cat("\033[1mGray dotted line represents median\033[0m\n")
options(repr.plot.width = 10, repr.plot.height = 6)

# Combat Plot
violin_plot_combat_jit <- plot_violin(violin_data_combat, "Combat (QCS)")
print(violin_plot_combat_jit)

# Transform and prepare the dataset for WaveICA
QCS_data_trans_wave <- as.data.frame(t(QCS_data_wave))
QCS_data_trans_wave[] <- lapply(QCS_data_trans_wave, as.numeric)

# Extract slide number
slide_number_wave <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_wave))
slide_number_wave <- as.numeric(slide_number_wave)

# Create violin plot data frame for WaveICA
violin_data_wave <- data.frame(
  Slide = slide_number_wave,
  Batch = QCS_data_wave$batch,
  Value = unlist(QCS_data_trans_wave[3, ])
)

# Scale WaveICA data by its mean
violin_data_wave <- scale_by_mean(violin_data_wave)

# WaveICA Plot
violin_plot_wave_jit <- plot_violin(violin_data_wave, "WaveICA (QCS)")
print(violin_plot_wave_jit)

# Transform and prepare the dataset for NormAE
QCS_data_trans_norm <- as.data.frame(t(QCS_data_norm))
QCS_data_trans_norm[] <- lapply(QCS_data_trans_norm, as.numeric)

# Extract slide number
slide_number_norm <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_norm))
slide_number_norm <- as.numeric(slide_number_norm)

# Create violin plot data frame for NormAE
violin_data_norm <- data.frame(
  Slide = slide_number_norm,
  Batch = QCS_data_norm$batch,
  Value = unlist(QCS_data_trans_norm[3, ])
)

# Scale NormAE data by its mean
violin_data_norm <- scale_by_mean(violin_data_norm)

# NormAE Plot
violin_plot_norm_jit <- plot_violin(violin_data_norm, "NormAE (QCS)")
print(violin_plot_norm_jit)
```
:::

::: {#corr_violinplot2 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Overview Intensity Plot (Propranolol) ##
library(gridExtra)
combined_violin_plots <- grid.arrange(violin_plot_combat_jit,
                                      violin_plot_wave_jit,
                                      violin_plot_norm_jit,
                                      ncol = 1,
                                      heights = c(1,1,1))
print(combined_violin_plots)
```
:::

::: {#corr_violinplot3 .cell .r}
```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(RColorBrewer)

# Function to scale data by its mean
scale_by_mean <- function(data_frame) {
  mean_value <- mean(data_frame$Value)
  sd_value <- sd(data_frame$Value)  
  data_frame <- data_frame %>%
    mutate(Value = (Value - mean_value) / sd_value) # Z-score normalization
  return(data_frame)
}


# Define the colors for the first three batches
manual_colors <- c("1" = "Red", "2" = "Green", "3" = "Blue")

# Plot function to ensure consistent scaling
plot_violin <- function(data, title) {
  unique_batches <- unique(data$Batch)
  additional_batches <- setdiff(unique_batches, names(manual_colors))
  
  if (length(additional_batches) > 0) {
    additional_colors <- colorRampPalette(brewer.pal(9, "Set3"))(length(additional_batches))
    additional_colors <- setNames(additional_colors, additional_batches)
  } else {
    additional_colors <- c()
  }
  
  all_colors <- c(manual_colors, additional_colors)
  
  ggplot(data, aes(x = factor(Slide), y = Value, fill = factor(Batch))) +
    geom_violin(position = position_dodge(width = 0.5), trim = FALSE, width = 1) +
    stat_summary(fun = median, geom = "point", shape = 20, size = 3, color = "black") +
    geom_point(position = position_jitter(width = 0.1), alpha = 0.5) + 
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray", linewidth = 1) +
    scale_fill_manual(values = all_colors) +
    labs(x = "Slide Number", y = "Scaled Peak Data", title = title) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 25),
      axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1, face = "bold", size = 25),
      axis.title = element_text(face = "bold", size = 25),  
      plot.title = element_text(face = "bold", size = 35),  
      axis.text = element_text(size = 20)
    )
}

# Combat Plot
# Transform and prepare the dataset for Combat
QCS_data_trans_combat <- as.data.frame(t(IS_data_combat))
QCS_data_trans_combat[] <- lapply(QCS_data_trans_combat, as.numeric)

# Extract slide number
slide_number_combat <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_combat))
slide_number_combat <- as.numeric(slide_number_combat)

# Create violin plot data frame for Combat
violin_data_combat <- data.frame(
  Slide = slide_number_combat,
  Batch = QCS_data_combat$batch,
  Value = unlist(QCS_data_trans_combat[3, ])
)

# Scale Combat data by its mean
violin_data_combat <- scale_by_mean(violin_data_combat)

# Plot the data with each dataset scaled by its mean
options(repr.plot.width = 10, repr.plot.height = 6)
violin_plot_combat_jit_d7 <- plot_violin(violin_data_combat, "Combat (Internal Standard)")
print(violin_plot_combat_jit_d7)

# WaveICA Plot
# Transform and prepare the dataset for WaveICA
QCS_data_trans_wave <- as.data.frame(t(IS_data_wave))
QCS_data_trans_wave[] <- lapply(QCS_data_trans_wave, as.numeric)

# Extract slide number
slide_number_wave <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_wave))
slide_number_wave <- as.numeric(slide_number_wave)

# Create violin plot data frame for WaveICA
violin_data_wave <- data.frame(
  Slide = slide_number_wave,
  Batch = QCS_data_wave$batch,
  Value = unlist(QCS_data_trans_wave[3, ])
)

# Scale WaveICA data by its mean
violin_data_wave <- scale_by_mean(violin_data_wave)

# WaveICA Plot
violin_plot_wave_jit_d7 <- plot_violin(violin_data_wave, "WaveICA (Internal Standard)")
print(violin_plot_wave_jit_d7)

# NormAE Plot
# Transform and prepare the dataset for NormAE
QCS_data_trans_norm <- as.data.frame(t(IS_data_norm))
QCS_data_trans_norm[] <- lapply(QCS_data_trans_norm, as.numeric)

# Extract slide number
slide_number_norm <- gsub("^.*S(\\d+)_.*", "\\1", names(QCS_data_trans_norm))
slide_number_norm <- as.numeric(slide_number_norm)

# Create violin plot data frame for NormAE
violin_data_norm <- data.frame(
  Slide = slide_number_norm,
  Batch = QCS_data_norm$batch,
  Value = unlist(QCS_data_trans_norm[3, ])
)

# Scale NormAE data by its mean
violin_data_norm <- scale_by_mean(violin_data_norm)

# NormAE Plot
violin_plot_norm_jit_d7 <- plot_violin(violin_data_norm, "NormAE (Internal Standard)")
print(violin_plot_norm_jit_d7)
```
:::

::: {.cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Overview Intensity Plot (D7_QCS) ##
library(gridExtra)
combined_violin_plots_d7 <- grid.arrange(violin_plot_combat_jit_d7, 
                                         violin_plot_wave_jit_d7,
                                         violin_plot_norm_jit_d7,
                                         ncol = 1,
                                         heights = c(1,1,1))
print(combined_violin_plots_d7)
```
:::

::: {#corr_pca_plot.cell .markdown}
## 4. PCA Plot {#corr_pca_2}
:::

::: r
```{r}
## PCA plot ##
library(stringr)
library(ggplot2)
library(scales)  # For color palette

# Combat #
options(repr.plot.width = 10, repr.plot.height = 6) 
adjusted <- combat_result_interday_df

batch_matrix <- data.frame(adjusted)
sample_ID <- str_extract(colnames(batch_matrix), "(S|m/z)\\d+")

# Create the regular expression pattern for sample_set
pattern <- paste(sample_set_2, collapse = "|")

# Extract sample types from column names using the defined pattern
sample_types_combat <- str_extract(colnames(batch_matrix), pattern)
sample_types_combat[is.na(sample_types_combat)] <- "QCS" 

# Transpose the data so that samples are on rows and features on columns
batch_data_t <- t(as.matrix(batch_matrix))

# Create a new data frame with the transposed matrix
batch_data_t_df <- as.data.frame(batch_data_t)

# Perform PCA, assuming batch_data_t_df contains the transposed data
batch_pca_combat <- prcomp(batch_data_t_df, center = TRUE, scale. = TRUE)

# Create a data frame for plotting the PCA
pca_data_combat <- data.frame(Sample = sample_ID, batch_pca_combat$x)

# Calculate the PC1 and PC2 scores
pc1_score <- batch_pca_combat$sdev[1]^2
pc2_score <- batch_pca_combat$sdev[2]^2

# Calculate the total score as the sum of PC1 and PC2 scores
total_score <- pc1_score + pc2_score

# Display the score 
total_score_text_recon <- paste("Total Score:", round(total_score / sum(batch_pca_combat$sdev^2) * 100, 2), "%")
cat(total_score_text_recon)

# Generate a color palette for tissue types, with "QCS" always in black
unique_types <- unique(sample_types_combat[sample_types_combat != "QCS"])
color_palette <- scales::hue_pal()(length(unique_types))
color_mapping <- c("QCS" = "black", setNames(color_palette, unique_types))

# Plot PCA with colored sample dots based on sample type
pca_data_combat$Type <- sample_types_combat

plot_combat <- ggplot(pca_data_combat, aes(x = PC1, y = PC2, color = Type, label = Sample)) +
  geom_point(size = 5) +
  geom_text(hjust = 1.5, vjust = 1.5, size = 8, check_overlap = TRUE, show.legend = FALSE) +
  xlab(paste("PC1 - ", round(batch_pca_combat$sdev[1]^2 / sum(batch_pca_combat$sdev^2) * 100, 2), "% Variance")) +
  ylab(paste("PC2 - ", round(batch_pca_combat$sdev[2]^2 / sum(batch_pca_combat$sdev^2) * 100, 2), "% Variance")) +
  ggtitle("Combat") +
  labs(color = "Sample Types") +  
  scale_color_manual(values = color_mapping) +  # Apply custom colors
  theme_bw() +
  theme(
    legend.position = "right",
    legend.title = element_text(size = 10, face = 'bold'),
    legend.text = element_text(size = 10),
    axis.text = element_text(size = 25, face = 'bold'), 
    axis.title = element_text(size = 25, face = 'bold'),
    plot.title = element_text(size = 40, hjust = 0.5, face = 'bold')
  )
print(plot_combat)
```
:::

::: r
```{r}
## PCA plot ##
library(stringr)
library(ggplot2)
library(scales)  # For color palette

# WaveICA #
adjusted <- as.data.frame(t(waveica_result_interday)) # check file path/variable 

options(repr.plot.width = 10, repr.plot.height = 6) # adjust desired width and height of plot 
batch_matrix <- data.frame(adjusted)
sample_ID <- str_extract(colnames(batch_matrix), "(S|m/z)\\d+")

# Create the regular expression pattern for sample_set
pattern <- paste(sample_set_2, collapse = "|")

# Extract sample types from column names using the defined pattern
sample_types_wave <- str_extract(colnames(batch_matrix), pattern)
sample_types_wave[is.na(sample_types_wave)] <- "QCS" 

# Transpose the data so that samples are on rows and features on columns
batch_data_t <- t(as.matrix(batch_matrix))

# Create a new data frame with the transposed matrix
batch_data_t_df <- as.data.frame(batch_data_t)

# Perform PCA, assuming batch_data_t_df contains the transposed data
batch_pca_wave <- prcomp(batch_data_t_df, center = TRUE, scale. = TRUE)

# Create a data frame for plotting the PCA
pca_data_wave <- data.frame(Sample = sample_ID, batch_pca_wave$x)

# Calculate the PC1 and PC2 scores
pc1_score <- batch_pca_wave$sdev[1]^2
pc2_score <- batch_pca_wave$sdev[2]^2

# Calculate the total score as the sum of PC1 and PC2 scores
total_score <- pc1_score + pc2_score

# Display the score 
total_score_text_recon <- paste("Total Score:", round(total_score / sum(batch_pca_wave$sdev^2) * 100, 2), "%")
cat(total_score_text_recon)

# Generate a color palette for tissue types, with "QCS" always in black
unique_types <- unique(sample_types_wave[sample_types_wave != "QCS"])
color_palette <- scales::hue_pal()(length(unique_types))
color_mapping <- c("QCS" = "black", setNames(color_palette, unique_types))

# Plot PCA with colored sample dots based on sample type
pca_data_wave$Type <- sample_types_wave

plot_wave <- ggplot(pca_data_wave, aes(x = PC1, y = PC2, color = Type, label = Sample)) +
  geom_point(size = 5) +
  geom_text(hjust = 1.5, vjust = 1.5, size = 8, check_overlap = TRUE, show.legend = FALSE) +
  xlab(paste("PC1 - ", round(batch_pca_wave$sdev[1]^2 / sum(batch_pca_wave$sdev^2) * 100, 2), "% Variance")) +
  ylab(paste("PC2 - ", round(batch_pca_wave$sdev[2]^2 / sum(batch_pca_wave$sdev^2) * 100, 2), "% Variance")) +
  ggtitle("WaveICA") +
  labs(color = "Sample Types") +  
  scale_color_manual(values = color_mapping) +  # Apply custom colors
  theme_bw() +
  theme(
    legend.position = "right",
    legend.title = element_text(size = 10, face = 'bold'),
    legend.text = element_text(size = 10),
    axis.text = element_text(size = 25, face = 'bold'), 
    axis.title = element_text(size = 25, face = 'bold'),
    plot.title = element_text(size = 40, hjust = 0.5, face = 'bold')
  )
print(plot_wave)
```
:::

::: {#corr_pca_plot2 .cell .r}
```{r}
library(stringr)
library(ggplot2)

# NormAE #
adjusted <- normae_result_interday
options(repr.plot.width = 10, repr.plot.height = 6) # adjust desired width and height of plot 
batch_matrix <- data.frame(adjusted)
sample_ID <- str_extract(colnames(batch_matrix), "(S|m/z)\\d+")

# Create the regular expression pattern for sample_set
pattern <- paste(sample_set_2, collapse = "|")

# Extract sample types from column names using the defined pattern
sample_types_norm <- str_extract(colnames(batch_matrix), pattern)
sample_types_norm[is.na(sample_types_norm)] <- "QCS" # assigns Na tissue samples as QCS

# Transpose the data so that samples are on rows and features on columns
batch_data_t <- t(as.matrix(batch_matrix))

# Create a new data frame with the transposed matrix
batch_data_t_df <- as.data.frame(batch_data_t)

# Perform PCA, assuming batch_data_t_df contains the transposed data
batch_pca_norm <- prcomp(batch_data_t_df, center = TRUE, scale. = TRUE)

# Create a data frame for plotting the PCA
pca_data_norm <- data.frame(Sample = sample_ID, batch_pca_norm$x)

# Plot PCA with colored sample dots based on sample type
pca_data_norm$Score <- pca_data_norm$PC1 + pca_data_norm$PC2
pca_data_norm$Type <- sample_types_norm

# Calculate the PC1 and PC2 scores
pc1_score <- batch_pca_norm$sdev[1]^2
pc2_score <- batch_pca_norm$sdev[2]^2

# Calculate the total score as the sum of PC1 and PC2 scores
total_score <- pc1_score + pc2_score

# Display the score 
total_score_text_recon <- paste("Total Score:", round(total_score / sum(batch_pca_norm$sdev^2) * 100, 2), "%")
cat(total_score_text_recon)

# Generate a color palette for the tissue types
unique_types <- unique(sample_types_norm[sample_types_norm != "QCS"])
color_palette <- scales::hue_pal()(length(unique_types))
color_mapping <- c("QCS" = "black", setNames(color_palette, unique_types))

# Create PCA plot
plot_norm <- ggplot(pca_data_norm, aes(x = PC1, y = PC2, color = sample_types_norm, label = Sample)) +
  geom_point(size = 5) +
  geom_text(hjust = 1.5, vjust = 1.5, size = 8, check_overlap = TRUE, show.legend = FALSE) +
  xlab(paste("PC1 - ", round(batch_pca_norm$sdev[1]^2 / sum(batch_pca_norm$sdev^2) * 100, 2), "% Variance")) +
  ylab(paste("PC2 - ", round(batch_pca_norm$sdev[2]^2 / sum(batch_pca_norm$sdev^2) * 100, 2), "% Variance")) +
  ggtitle("NormAE") +
  labs(color = "Sample Types") +  # Set the legend title
  scale_color_manual(values = color_mapping) +  # Manually set the colors
  theme_bw() +
  theme(
    legend.position = "right",
    legend.title = element_text(size = 10, face = 'bold'),
    legend.text = element_text(size = 10),
    axis.text = element_text(size = 25, face = 'bold'), 
    axis.title = element_text(size = 25, face = 'bold'),
    plot.title = element_text(size = 40, hjust = 0.5, face = 'bold')
  )

print(plot_norm)
```
:::

::: {#corr_pca_plot3 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Overview PCA PLOT ##
library(gridExtra)
combined_pca_plots <- grid.arrange(plot_combat,
                                   plot_wave,
                                   plot_norm,
                                   ncol = 1,
                                   heights = c(1,1,1))
print(combined_pca_plots)
```
:::

::: {#corr_pca_plot4 .cell .markdown}
## 5. QCS PCA Plot {#corr_qcs_pca_2}
:::

::: {.cell .r}
```{r}
## QCS PCA Plot ##
# combat #
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(cowplot)
library(gridExtra)

# gets rid of plot format
options(repr.plot.width = NULL, repr.plot.height = NULL)

# Calculate PCA scores
pca_scores <- batch_pca_combat$x

# Identify QCS samples based on sample types
qcs_samples <- which(sample_types_combat == "QCS") 

# Extract PCA scores for QCS samples
qcs_scores <- pca_scores[qcs_samples, 1:2] # obtaining only PC1 and PC2

# Compute the centroid of QCS samples
qcs_centroid <- colMeans(qcs_scores)

# Add batch info
qcs_batch_info <- batch_info_2[qcs_samples, "batch"]

qcs_data_combat <- data.frame(
  PC1 = qcs_scores[, 1],
  PC2 = qcs_scores[, 2],
  Batch = as.factor(qcs_batch_info)
)

# Calculate PC1 and PC2 variances
pc1_variance <- round(batch_pca_combat$sdev[1]^2 / sum(batch_pca_combat$sdev^2) * 100, 2)
pc2_variance <- round(batch_pca_combat$sdev[2]^2 / sum(batch_pca_combat$sdev^2) * 100, 2)

# Calculate distance of individual samples from centroids 
coordinate_PC1 <- (qcs_scores[, 1] - qcs_centroid["PC1"])^2
coordinate_PC2 <- (qcs_scores[, 2] - qcs_centroid["PC2"])^2

# Add up distances and sqrt them
distances_from_centroid <- sqrt(coordinate_PC1 + coordinate_PC2)

# Calculate average Euclidean distance
average_distance_ec_combat <- mean(distances_from_centroid)

# Plot PCA plot with QCS samples and their centroid
pca_plot_qcs_combat <- ggplot(qcs_data_combat, aes(x = PC1, y = PC2, color = Batch)) +
  geom_point(size = 7) +  # Plot QCS samples with color based on batch number
  geom_point(data = data.frame(PC1 = qcs_centroid[1], PC2 = qcs_centroid[2]), aes(x = PC1, y = PC2), shape = 17, fill = "black", color = "black", size = 5) +  # Plot centroid as triangle with filled black color
  labs(x = paste("PC1 (", pc1_variance, "% Variance)"), y = paste("PC2 (", pc2_variance, "% Variance)"), title = "Combat (QCS)") +
  theme_bw() +
  theme(axis.title.x = element_text(face = "bold", size = 15),
        axis.title.y = element_text(face = "bold", size = 15),
        axis.text = element_text(size = 15, face = "bold"),
        plot.margin = margin(20, 50, 10, 50),  
        plot.title = element_text(face = "bold", size = 20))

# Creating data frame for average euclidean distance
average_distance_qcs_df_combat <- data.frame(
    Pair = 'Average Euclidean Distance',
    Distance = round(average_distance_ec_combat, 3)
    )

# Create a table plot
table_plot_qcs_combat <- tableGrob(average_distance_qcs_df_combat, theme = ttheme_minimal(base_size = 20), rows = NULL)

# Combine the PCA plot and the table
combined_plot_combat_qcs <- plot_grid(pca_plot_qcs_combat, table_plot_qcs_combat, ncol = 1, align = "v", axis = "lr", rel_heights = c(3, 1))

# Print the combined plot
print(combined_plot_combat_qcs)
```
:::

::: {#corr_pca_plot5 .cell .r}
```{r}
## QCS PCA Plot ##
# waveica #
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(cowplot)
library(gridExtra)

# gets rid of plot format
options(repr.plot.width = NULL, repr.plot.height = NULL)

# Calculate PCA scores
pca_scores <- batch_pca_wave$x

# Identify QCS samples based on sample types
qcs_samples <- which(sample_types_wave == "QCS")

# Extract PCA scores for QCS samples
qcs_scores <- pca_scores[qcs_samples, 1:2] # only obtaining PC1 and PC2

# Compute the centroid of QCS samples
qcs_centroid <- colMeans(qcs_scores)

# Add batch info
qcs_batch_info <- batch_info_2[qcs_samples, "batch"]

qcs_data_wave <- data.frame(
  PC1 = qcs_scores[, 1],
  PC2 = qcs_scores[, 2],
  Batch = as.factor(qcs_batch_info)
)

# Calculate PC1 and PC2 variances
pc1_variance <- round(batch_pca_wave$sdev[1]^2 / sum(batch_pca_wave$sdev^2) * 100, 2)
pc2_variance <- round(batch_pca_wave$sdev[2]^2 / sum(batch_pca_wave$sdev^2) * 100, 2)

# Calculate the distance from individual samples from centroids
coordinate_PC1 <- (qcs_scores[, 1] - qcs_centroid["PC1"])^2
coordinate_PC2 <- (qcs_scores[, 2] - qcs_centroid["PC2"])^2

# Add distance together and sqrt them  
distances_from_centroid <- sqrt(coordinate_PC1 + coordinate_PC2)

# Calculate average Euclidean distance
average_distance_ec_wave <- mean(distances_from_centroid)

# Plot PCA plot with QCS samples and their centroid
pca_plot_qcs_wave <- ggplot(qcs_data_wave, aes(x = PC1, y = PC2, color = Batch)) +
  geom_point(size = 7) +  # Plot QCS samples with color based on batch number
  geom_point(data = data.frame(PC1 = qcs_centroid[1], PC2 = qcs_centroid[2]), aes(x = PC1, y = PC2), shape = 17, fill = "black", color = "black", size = 5) +  # Plot centroid as triangle with filled black color
  labs(x = paste("PC1 (", pc1_variance, "% Variance)"), y = paste("PC2 (", pc2_variance, "% Variance)"), title = "WaveICA (QCS)") +
  theme_bw() +
  theme(axis.title.x = element_text(face = "bold", size = 15),
        axis.title.y = element_text(face = "bold", size = 15),
        axis.text = element_text(size = 15, face = "bold"),
        plot.margin = margin(20, 50, 10, 50),  
        plot.title = element_text(face = "bold", size = 20))

# Creating data frame for average euclidean distance
average_distance_qcs_df_wave <- data.frame(
    Pair = 'Average Euclidean Distance',
    Distance = round(average_distance_ec_wave, 3)
    )

# Create a table plot
table_plot_qcs_wave <- tableGrob(average_distance_qcs_df_wave, theme = ttheme_minimal(base_size = 20), rows = NULL)

# Combine the PCA plot and the table
combined_plot_wave_qcs <- plot_grid(pca_plot_qcs_wave, table_plot_qcs_wave, ncol = 1, align = "v", axis = "lr", rel_heights = c(3, 1))

# Print the combined plot
print(combined_plot_wave_qcs)
```
:::

::: {.cell .r}
```{r}
## QCS PCA Plot ##
# normae #
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(cowplot)
library(gridExtra)

# gets rid of plot format
options(repr.plot.width = NULL, repr.plot.height = NULL)

# Calculate PCA scores
pca_scores <- batch_pca_norm$x

# Identify QCS samples based on sample types
qcs_samples <- which(sample_types_norm == "QCS")

# Extract PCA scores for QCS samples
qcs_scores <- pca_scores[qcs_samples, 1:2] # obtaining only PC1 and PC2

# Compute the centroid of QCS samples
qcs_centroid <- colMeans(qcs_scores)

# Add batch info
qcs_batch_info <- batch_info_normae[qcs_samples, "batch"]

qcs_data_norm <- data.frame(
  PC1 = qcs_scores[, 1],
  PC2 = qcs_scores[, 2],
  Batch = as.factor(qcs_batch_info)
)

# Calculate PC1 and PC2 variances
pc1_variance <- round(batch_pca_norm$sdev[1]^2 / sum(batch_pca_norm$sdev^2) * 100, 2)
pc2_variance <- round(batch_pca_norm$sdev[2]^2 / sum(batch_pca_norm$sdev^2) * 100, 2)

# Calculate distance of individual samples 
coordinate_PC1 <- (qcs_scores[, 1] - qcs_centroid["PC1"])^2
coordinate_PC2 <- (qcs_scores[, 2] - qcs_centroid["PC2"])^2

# Add distances together and sqrt them
distances_from_centroid <- sqrt(coordinate_PC1 + coordinate_PC2)

# Calculate average Euclidean distance
average_distance_ec_norm <- mean(distances_from_centroid)

# Plot PCA plot with QCS samples and their centroid
pca_plot_qcs_norm <- ggplot(qcs_data_norm, aes(x = PC1, y = PC2, color = Batch)) +
  geom_point(size = 7) +  # Plot QCS samples with color based on batch number
  geom_point(data = data.frame(PC1 = qcs_centroid[1], PC2 = qcs_centroid[2]), aes(x = PC1, y = PC2), shape = 17, fill = "black", color = "black", size = 5) +  # Plot centroid as triangle with filled black color
  labs(x = paste("PC1 (", pc1_variance, "% Variance)"), y = paste("PC2 (", pc2_variance, "% Variance)"), title = "NormAE (QCS)") +
  theme_bw() +
  theme(axis.title.x = element_text(face = "bold", size = 15),
        axis.title.y = element_text(face = "bold", size = 15),
        axis.text = element_text(size = 15, face = "bold"),
        plot.margin = margin(20, 50, 10, 50),  
        plot.title = element_text(face = "bold", size = 20))

# Creating data frame for average Euclidean distance
average_distance_qcs_df_norm <- data.frame(
    Pair = 'Average Euclidean Distance',
    Distance = round(average_distance_ec_norm, 3)
    )

# Create a table plot
table_plot_qcs_norm <- tableGrob(average_distance_qcs_df_norm, theme = ttheme_minimal(base_size = 20), rows = NULL)

# Combine the PCA plot and the table
combined_plot_norm_qcs <- plot_grid(pca_plot_qcs_norm, table_plot_qcs_norm, ncol = 1, align = "v", axis = "lr", rel_heights = c(3, 1))

# Print the combined plot
print(combined_plot_norm_qcs)
```
:::

::: {.cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Overview PCA PLOT ##
library(gridExtra)
combined_qcs_pca_plots <- grid.arrange(combined_plot_qcs,
                                       combined_plot_TIC_qcs,
                                       combined_plot_combat_qcs,
                                       combined_plot_wave_qcs,
                                       combined_plot_norm_qcs,
                                       ncol = 1,
                                       heights = c(1,1,1,1))
print(combined_qcs_pca_plots)
```
:::

::: {#corr_tissue_rsd .cell .markdown}
## 6. Tissue RSD {#corr_tissue_rsd_2}
:::

::: {.cell .r}
```{r}
## run these functions first ##
# 1: Function to calculate rsd for tissue
calculate_batch_rsd_combined <- function(tissue_samples) {
  
  calculate_batch_rsd <- function(sample_dataset, batch_number) {
    # Extract data for the specified batch number
    batch_data <- sample_dataset[sample_dataset$batch == batch_number, -(1:2)]
    # Check if there are any samples for this batch
    if (nrow(batch_data) == 0) {
      return("NA  NA%")  # Return NA if no samples exist for this batch
    }
    
    # Calculate mean and standard deviation for each analyte
    means <- apply(batch_data, 2, mean, na.rm = TRUE)
    std_devs <- apply(batch_data, 2, sd, na.rm = TRUE)

    # Calculate RSD
    rsd <- (std_devs / means) * 100
    
    # Calculate mean RSD and standard deviation of RSD
    mean_rsd <- mean(rsd)
    std_rsd <- sd(rsd)
    
    # Format the results
    rsd_formatted <- sprintf("%.2f  %.2f%%", mean_rsd, std_rsd)
    
    # Return the formatted RSD
    return(rsd_formatted)
  }
  
  calculate_interday_rsd <- function(sample_dataset) {
    # Extract data for interday calculation
    interday_data <- sample_dataset[, -(1:2)]
    
    # Check if there are any samples for interday calculation
    if (nrow(interday_data) == 0) {
      return("NA  NA%")  # Return NA if no interday samples exist
    }
    
    # Calculate mean and standard deviation for each analyte
    means <- apply(interday_data, 2, mean, na.rm = TRUE)
    std_devs <- apply(interday_data, 2, sd, na.rm = TRUE)
    
    # Calculate RSD
    rsd <- (std_devs / means) * 100
    
    # Calculate mean RSD and standard deviation of RSD
    mean_rsd <- mean(rsd)
    std_rsd <- sd(rsd)
    
    # Format the results
    rsd_formatted <- sprintf("%.2f  %.2f%%", mean_rsd, std_rsd)
    
    # Return the formatted RSD
    return(rsd_formatted)
  }
  
  calculate_batch_rsd_multiple <- function(sample_dataset, unique_batches) {
    rsd_results <- list()
    for (batch_number in unique_batches) {
      rsd_results[[as.character(batch_number)]] <- calculate_batch_rsd(sample_dataset, batch_number)
    }
    return(rsd_results)
  }
  
  unique_tissues <- unique(gsub(".*_(\\w+)_\\d+.*", "\\1", rownames(tissue_samples)))
  
  rsd_results <- list()
  
  for (tissue_type in unique_tissues) {
    tissue_data <- tissue_samples[grep(paste0(tissue_type, "_"), rownames(tissue_samples)), ]
    
    sample_numbers <- as.numeric(gsub(".*S(\\d+)_.*", "\\1", rownames(tissue_data)))
    ordered_indices <- order(sample_numbers)
    tissue_data <- tissue_data[ordered_indices, ]
    
    tissue_data <- replace(tissue_data, tissue_data < 0, 1)
    
    unique_batches <- unique(tissue_data$batch)
    rsd_results_tissue <- calculate_batch_rsd_multiple(tissue_data, unique_batches)
    
    # Initialize dataframe to store results
    rsd_df_tissue <- data.frame(
      Batch = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
      RSD = NA
    )
    
    # Fill in RSD values where available for batch-specific RSDs
    for (i in 1:length(rsd_df_tissue$Batch)) {
      batch_number <- i  # Adjust based on batch number indexing
      if (as.character(batch_number) %in% names(rsd_results_tissue)) {
        rsd_df_tissue$RSD[i] <- rsd_results_tissue[[as.character(batch_number)]]
      } else {
        rsd_df_tissue$RSD[i] <- "NA  NA%"  # Handle case where batch RSD is missing
      }
    }
    
    # Calculate interday RSD and insert into the dataframe
    interday_rsd <- calculate_interday_rsd(tissue_data)
    rsd_df_tissue$RSD[length(rsd_df_tissue$Batch)] <- interday_rsd
    
    rsd_results[[tissue_type]] <- rsd_df_tissue
  }
  
  return(rsd_results)
}

# 2: Function to generate HTML tables for each tissue
generate_rsd_table <- function(rsd_results, tissue_name) {
  rsd_df <- rsd_results[[tissue_name]]
  kable(rsd_df, format = "html", row.names = FALSE) %>%
    kable_styling(full_width = FALSE)
}
```
:::

::: {#corr_tissue_rsd2 .cell .r}
```{r}
## Tissue RSD Table ##

# load libraries
library(kableExtra)
library(IRdisplay)

# Combat #
data <- combat_result_interday_df
row_names <- rownames(data)
batch_info_norm <- batch_info_2

injection_order_norm <- batch_info_norm$injection.order
batch_norm <- batch_info_norm$batch

# add injection_order and batch_info
new_data <- rbind(injection_order_norm, batch_norm, data)
new_row_names <- c("injection_order", "batch", row_names)
rownames(new_data) <- new_row_names

# Transpose the data
transposed_data <- as.data.frame(t(new_data))
sample_set_regex <- paste(sample_set_2, collapse = "|")
sample_set_rows <- grep(sample_set_regex, rownames(transposed_data))
tissue_samples <- transposed_data[sample_set_rows,]
row_names <- rownames(tissue_samples)
tissue_samples <- as.data.frame(apply(tissue_samples, 2, as.numeric))
rownames(tissue_samples) <- row_names

# use function to calculate tissue rsd
rsd_results_combined_combat <- calculate_batch_rsd_combined(tissue_samples)
#print(rsd_results_combined_combat)

# Generate HTML tables for each tissue
html_tables_combat <- lapply(names(rsd_results_combined_combat), function(tissue_name) {
  rsd_table <- generate_rsd_table(rsd_results_combined_combat, tissue_name)
  table_name <- paste("<h2 style='text-align: center;'>", tissue_name, " RSD Table</h2>", sep = "")
  paste("<div style='display: inline-block; margin-right: 20px; text-align: center;'>", table_name, as.character(rsd_table), "</div>")
})

# Combine HTML tables into a single string
html_content_combat <- paste(html_tables_combat, collapse = "")

# Wrap the combined HTML content in a div with text-align: center
centered_html_content_combat <- paste("<div style='text-align: center;'>", html_content_combat, "</div>")

cat("\033[1mTissue RSD table for Combat corrected dataset\033[0m\n")
# Display the centered HTML content in JupyterLab
display_html(centered_html_content_combat)
```
:::

::: {#corr_tissue_rsd3 .cell .r}
```{r}
## Tissue Variation RSD ##

# load libraries
library(kableExtra)
library(IRdisplay)

# WaveICA #
data <- as.data.frame(t(waveica_result_interday)) 
row_names <- rownames(data)
batch_info_norm <- batch_info_2

injection_order_norm <- batch_info_norm$injection.order
batch_norm <- batch_info_norm$batch

# add injection_order and batch_info
new_data <- rbind(injection_order_norm, batch_norm, data)
new_row_names <- c("injection_order", "batch", row_names)
rownames(new_data) <- new_row_names

# Transpose the data
transposed_data <- as.data.frame(t(new_data))
sample_set_regex <- paste(sample_set_2, collapse = "|")
sample_set_rows <- grep(sample_set_regex, rownames(transposed_data))
tissue_samples <- transposed_data[sample_set_rows,]
row_names <- rownames(tissue_samples)
tissue_samples <- as.data.frame(apply(tissue_samples, 2, as.numeric))
rownames(tissue_samples) <- row_names

# run function
rsd_results_combined_wave <- calculate_batch_rsd_combined(tissue_samples)
#print(rsd_results_combined_wave)

# Generate HTML tables for each tissue
html_tables_wave <- lapply(names(rsd_results_combined_wave), function(tissue_name) {
  rsd_table <- generate_rsd_table(rsd_results_combined_wave, tissue_name)
  table_name <- paste("<h2 style='text-align: center;'>", tissue_name, " RSD Table</h2>", sep = "")
  paste("<div style='display: inline-block; margin-right: 20px; text-align: center;'>", table_name, as.character(rsd_table), "</div>")
})

# Combine HTML tables into a single string
html_content_wave <- paste(html_tables_wave, collapse = "")

# Wrap the combined HTML content in a div with text-align: center
centered_html_content_wave <- paste("<div style='text-align: center;'>", html_content_wave, "</div>")

cat("\033[1mTissue RSD table for WaveICA corrected dataset\033[0m\n")
display_html(centered_html_content_wave)
```
:::

::: {#corr_tissue_rsd4 .cell .r}
```{r}
## Tissue Variation RSD ##

# load libraries
library(kableExtra)
library(IRdisplay)

# NormAE #
data <- normae_result_interday
row_names <- rownames(data)
rownames(data) <- row_names

batch_info_norm <- batch_info_normae

injection_order_norm <- batch_info_norm$injection.order
batch_norm <- batch_info_norm$batch  +  1

# add injection_order and batch_info
new_data <- rbind(injection_order_norm, batch_norm, data)
new_row_names <- c("injection_order", "batch", row_names)
rownames(new_data) <- new_row_names

# Transpose the data
transposed_data <- as.data.frame(t(new_data))
sample_set_regex <- paste(sample_set_2, collapse = "|")
sample_set_rows <- grep(sample_set_regex, rownames(transposed_data)) #126 obs of 121 variables
tissue_samples <- transposed_data[sample_set_rows,]
row_names <- rownames(tissue_samples)
tissue_samples <- as.data.frame(apply(tissue_samples, 2, as.numeric))
rownames(tissue_samples) <- row_names

# calculate tissue rsd using function 
rsd_results_combined_norm <- calculate_batch_rsd_combined(tissue_samples)

# Generate HTML tables for each tissue using function
html_tables_norm <- lapply(names(rsd_results_combined_norm), function(tissue_name) {
  rsd_table <- generate_rsd_table(rsd_results_combined_norm, tissue_name)
  table_name <- paste("<h2 style='text-align: center;'>", tissue_name, " RSD Table</h2>", sep = "")
  paste("<div style='display: inline-block; margin-right: 20px; text-align: center;'>", table_name, as.character(rsd_table), "</div>")
})

# Combine HTML tables into a single string
html_content_norm <- paste(html_tables_norm, collapse = "")

# Wrap the combined HTML content in a div with text-align: center
centered_html_content_norm <- paste("<div style='text-align: center;'>", html_content_norm, "</div>")

cat("\033[1mTissue RSD table for NormAE corrected dataset\033[0m\n")
display_html(centered_html_content_norm)
```
:::

::: {#corr_tissue_pca .cell .markdown}
## 8. Tissue PCA Plot (Intra/Intergroup) {#corr_tissue_pca_2}

**Intragroup Tissue PCA Plot**
:::

::: {#corr_tissue_pca2 .cell .r}
```{r}
# Load necessary libraries
library(ggplot2)
library(ggrepel)
library(gridExtra)
library(dplyr)

# Set plot dimensions
options(repr.plot.width = 10, repr.plot.height = 10)

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_combat %>%
  filter(Type %in% sample_set_2)

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate distances between each sample and its corresponding centroid within each tissue type
tissue_pca_data_with_centroids <- left_join(tissue_pca_data, centroids, by = "Type")
tissue_pca_data_with_centroids <- tissue_pca_data_with_centroids %>%
  mutate(distance_to_centroid = sqrt((PC1 - Centroid_PC1)^2 + (PC2 - Centroid_PC2)^2))

# Calculate average distance within each tissue type
tissue_avg_distances_combat <- tissue_pca_data_with_centroids %>%
  group_by(Type) %>%
  summarize(avg_distance_within_tissue = round(mean(distance_to_centroid), 3)) %>%
  rename('Average Distance Within Tissue' = avg_distance_within_tissue)

# Create intragroup PCA plot with distance lines for visual validation
tissue_intra_plot_combat <- ggplot(tissue_pca_data_with_centroids, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_segment(aes(x = PC1, y = PC2, xend = Centroid_PC1, yend = Centroid_PC2), linetype = "dashed") +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +
  labs(title = "Combat Tissue PCA (Intragroup)",
       x = paste("PC1 - ", round(batch_pca_combat$sdev[1]^2 / sum(batch_pca_combat$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_combat$sdev[2]^2 / sum(batch_pca_combat$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create table plot
table_plot_combat <- tableGrob(tissue_avg_distances_combat, rows = NULL)

# Arrange PCA plot and table plot
combined_plot_combat_intra <- grid.arrange(tissue_intra_plot_combat, table_plot_combat, ncol = 1, heights = c(3, 1))

# Print the combined plot
print(combined_plot_combat_intra)
```
:::

::: {#corr_tissue_pca3 .cell .r}
```{r}
# Load necessary libraries
library(gridExtra)
library(dplyr)

# Set plot dimensions
options(repr.plot.width = 10, repr.plot.height = 10)

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_wave %>%
  filter(Type %in% sample_set_2)

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate distances between each sample and its corresponding centroid within each tissue type
tissue_pca_data_with_centroids <- left_join(tissue_pca_data, centroids, by = "Type")
tissue_pca_data_with_centroids <- tissue_pca_data_with_centroids %>%
  mutate(distance_to_centroid = sqrt((PC1 - Centroid_PC1)^2 + (PC2 - Centroid_PC2)^2))

# Calculate average distance within each tissue type
tissue_avg_distances_wave <- tissue_pca_data_with_centroids %>%
  group_by(Type) %>%
  summarize(avg_distance_within_tissue = round(mean(distance_to_centroid), 3)) %>%
  rename('Average Distance Within Tissue' = avg_distance_within_tissue)

# Create intragroup PCA plot
tissue_intra_plot_wave <- ggplot(tissue_pca_data_with_centroids, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_segment(aes(x = PC1, y = PC2, xend = Centroid_PC1, yend = Centroid_PC2), linetype = "dashed") +  # Add dashed lines
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +
  labs(title = "WaveICA Tissue PCA (Intragroup)",
       x = paste("PC1 - ", round(batch_pca_wave$sdev[1]^2 / sum(batch_pca_wave$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_wave$sdev[2]^2 / sum(batch_pca_wave$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create table plot
table_plot_wave <- tableGrob(tissue_avg_distances_wave, rows = NULL)

# Arrange PCA plot and table plot
combined_plot_wave_intra <- grid.arrange(tissue_intra_plot_wave, table_plot_wave, ncol = 1, heights = c(3, 1))

# Print the combined plot
print(combined_plot_wave_intra)
```
:::

::: {.cell .r}
```{r}
## Tissue PCA plot Intragroup ##
# NormAE # 
library(gridExtra)
library(dplyr)

options(repr.plot.width = 10, repr.plot.height = 10)  # Adjust width and height as desired

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_norm %>%
  filter(Type %in% sample_set_2)

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate distances between each sample and its corresponding centroid within each tissue type
tissue_pca_data_with_centroids <- left_join(tissue_pca_data, centroids, by = "Type")
tissue_pca_data_with_centroids <- tissue_pca_data_with_centroids %>%
  mutate(distance_to_centroid = sqrt((PC1 - Centroid_PC1)^2 + (PC2 - Centroid_PC2)^2))

# Calculate average distance within each tissue type
tissue_avg_distances_norm <- tissue_pca_data_with_centroids %>%
  group_by(Type) %>%
  summarize(avg_distance_within_tissue = round(mean(distance_to_centroid), 3)) %>%
  rename('Average Distance Within Tissue' = avg_distance_within_tissue)

# Create intragroup pca plot
tissue_intra_plot_norm <- ggplot(tissue_pca_data_with_centroids, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_segment(aes(x = PC1, y = PC2, xend = Centroid_PC1, yend = Centroid_PC2), linetype = "dashed") +  # Add dashed lines
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +
  labs(title = "NormAE Tissue PCA (Intragroup)",
       x = paste("PC1 - ", round(batch_pca_norm$sdev[1]^2 / sum(batch_pca_norm$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_norm$sdev[2]^2 / sum(batch_pca_norm$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")


# Create table plot
table_plot_norm <- tableGrob(tissue_avg_distances_norm, rows = NULL)

# Arrange PCA plot and table plot
combined_plot_norm_intra <- grid.arrange(tissue_intra_plot_norm, table_plot_norm, ncol = 1, heights = c(3, 1))

# Print the combined plot
print(combined_plot_norm_intra)
```
:::

::: {#corr_tissue_pca4 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Overview Tissue PCA Plot ##
tissue_plots <- grid.arrange(combined_plot_intra,
                             combined_plot_TIC_intra,
                             combined_plot_combat_intra,
                             combined_plot_wave_intra,
                             combined_plot_norm_intra,
                             nrow = 1,
                             heights = c(1,1,1,1))
print(tissue_plots)
```
:::

::: {#corr_tissue_pca5 .cell .markdown}
**Intergroup Tissue PCA Plot**
:::

::: {#corr_tissue_pca6 .cell .r}
```{r}
## Tissue PCA Plot Intergroup ##
# Combat #
library(ggplot2)
library(dplyr)
library(ggrepel)
library(gridExtra)

options(repr.plot.width = 10, repr.plot.height = 10)  # Adjust width and height as desired

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_combat %>%
  filter(Type %in% sample_set_2)

# Check if tissue_pca_data is not empty
if (nrow(tissue_pca_data) == 0) {
  stop("No tissue samples found in the given sample_set_2.")
}

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate intergroup distances (pairwise distances between centroids)
tissue_combinations <- combn(unique(centroids$Type), 2, simplify = TRUE)

centroid_distances_df_combat <- data.frame(Tissue1 = character(), Tissue2 = character(), Pair_Distance = numeric())

for (i in 1:ncol(tissue_combinations)) {
  tissue_pair <- tissue_combinations[, i]
  centroid1 <- centroids %>% filter(Type == tissue_pair[1])
  centroid2 <- centroids %>% filter(Type == tissue_pair[2])
  distance <- sqrt((centroid1$Centroid_PC1 - centroid2$Centroid_PC1)^2 + (centroid1$Centroid_PC2 - centroid2$Centroid_PC2)^2)
  centroid_distances_df_combat <- rbind(centroid_distances_df_combat, data.frame(Tissue1 = tissue_pair[1], Tissue2 = tissue_pair[2], Pair_Distance = round(distance, 3)))
}
# Create the tissue PCA plot
tissue_intergroup_plot_combat <- ggplot(tissue_pca_data, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +  
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +  
  labs(title = "Combat Tissue PCA (Intergroup)",
       x = paste("PC1 - ", round(batch_pca_combat$sdev[1]^2 / sum(batch_pca_combat$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_combat$sdev[2]^2 / sum(batch_pca_combat$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create a table grob for centroid distances
centroid_table_combat <- tableGrob(centroid_distances_df_combat, rows = NULL)
print(centroid_distances_df_combat)

# Arrange plots and table vertically
combined_plot_combat_inter <- grid.arrange(tissue_intergroup_plot_combat, centroid_table_combat, ncol = 1, heights = c(3, 1))

# Print the combined plot
print(combined_plot_combat_inter)
```
:::

::: {.cell .r}
```{r}
## Tissue PCA Plot Intergroup ##
# WaveICA #
library(ggplot2)
library(dplyr)
library(ggrepel)
library(gridExtra)

options(repr.plot.width = 10, repr.plot.height = 10)  # Adjust width and height as desired

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_wave %>%
  filter(Type %in% sample_set_2)

# Check if tissue_pca_data is not empty
if (nrow(tissue_pca_data) == 0) {
  stop("No tissue samples found in the given sample_set.")
}

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate intergroup distances (pairwise distances between centroids)
tissue_combinations <- combn(unique(centroids$Type), 2, simplify = TRUE)

centroid_distances_df_wave <- data.frame(Tissue1 = character(), Tissue2 = character(), Pair_Distance = numeric())

for (i in 1:ncol(tissue_combinations)) {
  tissue_pair <- tissue_combinations[, i]
  centroid1 <- centroids %>% filter(Type == tissue_pair[1])
  centroid2 <- centroids %>% filter(Type == tissue_pair[2])
  distance <- sqrt((centroid1$Centroid_PC1 - centroid2$Centroid_PC1)^2 + (centroid1$Centroid_PC2 - centroid2$Centroid_PC2)^2)
  centroid_distances_df_wave <- rbind(centroid_distances_df_wave, data.frame(Tissue1 = tissue_pair[1], Tissue2 = tissue_pair[2], Pair_Distance = round(distance, 3)))
}

# Create the tissue PCA plot
tissue_intergroup_plot_wave <- ggplot(tissue_pca_data, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +  
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +  
  labs(title = "WaveICA Tissue PCA (Intergroup)",
       x = paste("PC1 - ", round(batch_pca_wave$sdev[1]^2 / sum(batch_pca_wave$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_wave$sdev[2]^2 / sum(batch_pca_wave$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create a table grob for centroid distances
centroid_table_wave <- tableGrob(centroid_distances_df_wave, rows = NULL)

# Arrange plots and table vertically
combined_plot_wave_inter <- grid.arrange(tissue_intergroup_plot_wave, centroid_table_wave, ncol = 1, heights = c(3, 1))

# Print the combined plot
print(combined_plot_wave_inter)
```
:::

::: {#corr_tissue_pca7 .cell .r}
```{r}
## Tissue PCA Plot Intergroup ##
# NormAE #
library(ggplot2)
library(dplyr)
library(ggrepel)
library(gridExtra)

options(repr.plot.width = 10, repr.plot.height = 10)  # Adjust width and height as desired

# Filter pca_data to include only tissue samples
tissue_pca_data <- pca_data_norm %>%
  filter(Type %in% sample_set_2)

# Check if tissue_pca_data is not empty
if (nrow(tissue_pca_data) == 0) {
  stop("No tissue samples found in the given sample_set.")
}

# Calculate centroids for each tissue type
centroids <- tissue_pca_data %>%
  group_by(Type) %>%
  summarize(Centroid_PC1 = mean(PC1), Centroid_PC2 = mean(PC2))

# Calculate intergroup distances (pairwise distances between centroids)
tissue_combinations <- combn(unique(centroids$Type), 2, simplify = TRUE)

centroid_distances_df_norm <- data.frame(Tissue1 = character(), Tissue2 = character(), Pair_Distance = numeric())

for (i in 1:ncol(tissue_combinations)) {
  tissue_pair <- tissue_combinations[, i]
  centroid1 <- centroids %>% filter(Type == tissue_pair[1])
  centroid2 <- centroids %>% filter(Type == tissue_pair[2])
  distance <- sqrt((centroid1$Centroid_PC1 - centroid2$Centroid_PC1)^2 + (centroid1$Centroid_PC2 - centroid2$Centroid_PC2)^2)
  centroid_distances_df_norm <- rbind(centroid_distances_df_norm, data.frame(Tissue1 = tissue_pair[1], Tissue2 = tissue_pair[2], Pair_Distance = round(distance, 3)))
}

# Create the tissue PCA plot
tissue_intergroup_plot_norm <- ggplot(tissue_pca_data, aes(x = PC1, y = PC2, color = Type)) +
  geom_point(size = 5) +
  geom_point(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, color = Type), shape = 18, size = 5) +
  geom_text_repel(data = centroids, aes(x = Centroid_PC1, y = Centroid_PC2, label = Type), 
                  direction = "both", size = 3) +  
  geom_text_repel(aes(label = Sample), direction = "both", size = 3) +  
  labs(title = "NormAE Tissue PCA (Intergroup)",
       x = paste("PC1 - ", round(batch_pca_norm$sdev[1]^2 / sum(batch_pca_norm$sdev^2) * 100, 2), "% Variance"),
       y = paste("PC2 - ", round(batch_pca_norm$sdev[2]^2 / sum(batch_pca_norm$sdev^2) * 100, 2), "% Variance")) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, face = 'bold'), 
        axis.title = element_text(size = 20, face = 'bold'),
        plot.title = element_text(size = 25, hjust = 0.5, face = 'bold'),
        legend.position = "right")

# Create a table grob for centroid distances
centroid_table_norm <- tableGrob(centroid_distances_df_norm, rows = NULL)

# Arrange plots and table vertically
combined_plot_norm_inter <- grid.arrange(tissue_intergroup_plot_norm, centroid_table_norm, ncol = 1, heights = c(3, 1))

# Print the combined plot
print(combined_plot_norm_inter)
```
:::

::: {.cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Overview Intergroup Tissue PCA Plot ##
combined_plots_interday <- grid.arrange(combined_plot_inter,
                                        combined_plot_TIC_inter,
                                        combined_plot_combat_inter,
                                        combined_plot_wave_inter,
                                        combined_plot_norm_inter,
                                        nrow = 1,
                                        heights = c(1,1,1,1,1))
print(combined_plots_interday)
```
:::

::: {.cell .markdown}
## Comparison {#comparison_2}

1.  [QCS_RSD_Overview](#qcs_rsd_overview_2)
2.  [QCS_Intensity_Plot_Overview](#qcs_intensity_overview_2)
3.  [QCS_Violin_Plot_Overview](#qcs_violin_overview_2)
4.  [QCS_PCA_Plot_Overview](#qcs_pca_overview_2)
5.  [Tissue_RSD_Overview](#tissue_rsd_overview_2)
6.  [PCA_Plot_Overview](#pca_overview_2)
7.  [Tissue_PCA_Plot_Overview](#tissue_pca_overview_2)
8.  [Average Distance Overview (Euclidean, Intra,
    Intergroup)](#distance_overview_2)
:::

::: {#corr_overview .cell .markdown}
## 1. QCS RSD Overview {#qcs_rsd_overview_2}
:::

::: {#corr_overview2 .cell .r}
```{r}
## QCS RSD Overview Table ##
# Create overview RSD table for Propranolol
overview_table_pro <- data.frame(
  Row_Names = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
  No_norm_RSD = rsd_QCS[2],  
  TIC_norm_RSD = rsd_QCS_TIC[2],
  IS_norm_RSD = rsd_ratio[2],
  Combat_RSD = rsd_QCS_combat[2],
  WaveICA_RSD = rsd_QCS_wave[2],
  NormAE_RSD = rsd_QCS_norm[2]
)

# Set the column names
colnames(overview_table_pro) <- c(paste("m/z value:", QCS_mz_value_2),"No Norm","TIC Norm","IS Norm", "Combat", "WaveICA", "NormAE")
library(kableExtra)
library(htmltools)
library(IRdisplay)

# Displaying overview RSD table
display_rsd_table_pro <- kable(overview_table_pro, format = "html", row.names = FALSE) %>%
  kable_styling(full_width = FALSE)

# Add table name
display_rsd_table_pro <- paste("<h2 style='text-align: center;'>Overview RSD Table QCS</h2>", 
                               as.character(display_rsd_table_pro))

# Save HTML table to a file
display_html(display_rsd_table_pro)

# Create overview RSD table for d7-Propranolol
overview_table_d7_pro <- data.frame(
  Row_Names = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
  No_norm_RSD = rsd_IS[2],
  TIC_norm_RSD = rsd_IS[2],
  Combat_RSD = rsd_IS_combat[2],
  WaveICA_RSD = rsd_IS_wave[2],
  NormAE_RSD = rsd_IS_norm[2]
)

# Set the column names
colnames(overview_table_d7_pro) <- c(paste("m/z value:", IS_mz_value_2),"No Norm","TIC Norm","Combat", "WaveICA", "NormAE")

library(kableExtra)
library(htmltools)
library(IRdisplay)

# Displaying overview RSD table
display_rsd_table_d7_pro <- kable(overview_table_d7_pro, format = "html", row.names = FALSE) %>%
  kable_styling(full_width = FALSE)

# Add table name
display_rsd_table_d7_pro <- paste("<h2 style='text-align: center;'>Overview RSD Table Internal Standard</h2>", 
                               as.character(display_rsd_table_d7_pro))

# Save HTML table to a file
display_html(display_rsd_table_d7_pro)
```
:::

::: {#corr_overview3 .cell .markdown}
## 2. QCS Intensity Plot Overview {#qcs_intensity_overview_2}
:::

::: {#corr_overview4 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Intensity Plot ##
library(gridExtra)
cat("\033[1mBlack dotted line represent standard deviation while red dotted line represent mean of intensity\033[0m\n")
combined_plots_intensity <- grid.arrange(intensity_plot,
                                         intensity_plot_TIC,
                                         intensity_plot_IS,
                                         intensity_plot_combat,
                                         intensity_plot_wave,
                                         intensity_plot_norm,
                                         nrow = 1,
                                         heights = c(1,1,1,1,1,1))
print(combined_plots_intensity)
```
:::

::: {#corr_overview5 .cell .markdown}
## 3. QCS Violin Plot Overview {#qcs_violin_overview_2}
:::

::: {.cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Violin Plot (Propranolol) ##
combined_plots_violin <- grid.arrange(violin_plot_jit,
                                      violin_plot_TIC_jit,
                                      violin_plot_IS_jit,
                                      violin_plot_combat_jit,
                                      violin_plot_wave_jit,
                                      violin_plot_norm_jit,
                                      nrow = 1,
                                      heights = c(1,1,1,1,1,1))
print(combined_plots_violin)
```
:::

::: {#corr_overview6 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Violin Plot (D7-Propranolol) ##
combined_plots_violin_d7 <- grid.arrange(violin_plot_jit_d7,
                                         violin_plot_TIC_jit_d7,
                                         violin_plot_combat_jit_d7,
                                         violin_plot_wave_jit_d7,
                                         violin_plot_norm_jit_d7,
                                         nrow = 1,
                                         heights = c(1,1,1,1,1))
print(combined_plots_violin_d7)
```
:::

::: {.cell .markdown}
## 4. PCA Plot Overview {#pca_overview_2}
:::

::: {.cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## PCA Plot ##
library(gridExtra)
combined_plots <- grid.arrange(plot,
                               plot_TIC,
                               plot_combat,
                               plot_wave,
                               plot_norm,
                               nrow = 1,
                               heights = c(1,1,1,1))
print(combined_plots)
```
:::

::: {.cell .markdown}
## 5. QCS PCA Plot Overview {#qcs_pca_overview_2}
:::

::: {#corr_overview7 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## QCS PCA PLOT ##
library(gridExtra)
combined_plots_qcs <- grid.arrange(combined_plot_qcs,
                                   combined_plot_TIC_qcs,
                                   combined_plot_combat_qcs,
                                   combined_plot_wave_qcs,
                                   combined_plot_norm_qcs,
                                   nrow = 1,
                                   heights = c(1,1,1,1,1))
print(combined_plots_qcs)
```
:::

::: {#corr_overview8 .cell .markdown}
## 6. Tissue RSD Overview {#tissue_rsd_overview_2}
:::

::: {#corr_overview9 .cell .r}
```{r}
## Tissue RSD Overview Table ##
# Initialize an empty list to store combined HTML tables for each tissue
combined_html_list <- list()

# Iterate over each tissue type
for (tissue_name in names(rsd_results_combined)) {
  # Extract RSD tables for the current tissue type
  rsd_table <- generate_rsd_table(rsd_results_combined, tissue_name)
  rsd_table_TIC <- generate_rsd_table(rsd_results_combined_TIC, tissue_name)  
  rsd_table_combat <- generate_rsd_table(rsd_results_combined_combat, tissue_name)
  rsd_table_wave <- generate_rsd_table(rsd_results_combined_wave, tissue_name)
  rsd_table_norm <- generate_rsd_table(rsd_results_combined_norm, tissue_name)

  # Combine HTML tables for the current tissue type horizontally
  combined_rsd_table <- paste("<h2 style='text-align: center;'>", tissue_name, " RSD Table</h2>",
                              "<div style='text-align: center;'>",
                              "<div style='display: inline-block; margin-right: 20px; text-align: center;'>",
                              "<h3>No Norm</h3>", rsd_table, "</div>",
                              "<div style='display: inline-block; margin-right: 20px; text-align: center;'>",
                              "<h3>TIC Norm</h3>", rsd_table_TIC, "</div>",
                              "<div style='display: inline-block; margin-right: 20px; text-align: center;'>",
                              "<h3>Combat</h3>", rsd_table_combat, "</div>",
                              "<div style='display: inline-block; margin-right: 20px; text-align: center;'>",
                              "<h3>WaveICA</h3>", rsd_table_wave, "</div>",
                              "<div style='display: inline-block; margin-right: 20px; text-align: center;'>",
                              "<h3>NormAE</h3>", rsd_table_norm, "</div>",
                              "</div>")
  
  # Add the combined HTML table to the list
  combined_html_list[[tissue_name]] <- combined_rsd_table
}

# Combine HTML tables into a single HTML table with four columns
combined_html <- paste("<table style='width:100%; border-collapse: collapse;'>", 
                       "<tr>", paste("<td style='vertical-align: top;'>", 
                                     unlist(combined_html_list), 
                                     "</td>", sep = ""), "</tr></table>")

# Wrap the combined HTML content in a div with text-align: center
centered_combined_html <- paste("<div style='text-align: center;'>", combined_html, "</div>")

# Display the centered HTML content in JupyterLab
display_html(centered_combined_html)
```
:::

::: {#corr_overview10 .cell .markdown}
## 7. Tissue PCA Plot Overview {#tissue_pca_overview_2}
:::

::: {#corr_overview11 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Tissue Intragroup Plot ##
tissue_plots_intra <- grid.arrange(tissue_intra_plot,
                                   tissue_intra_plot_TIC,
                                   tissue_intra_plot_combat,
                                   tissue_intra_plot_wave,
                                   tissue_intra_plot_norm,
                                   nrow = 1,
                                   heights = c(1,1,1,1,1))
print(tissue_plots_intra)
```
:::

::: {#corr_overview12 .cell .r}
```{r fig.height=12, fig.width=7, echo=FALSE}
## Tissue Intergroup Plot ##
combined_plots_interday <- grid.arrange(combined_plot_inter,
                                        combined_plot_TIC_inter,
                                        combined_plot_combat_inter,
                                        combined_plot_wave_inter,
                                        combined_plot_norm_inter,
                                        nrow = 1,
                                        heights = c(1,1,1,1,1))
print(combined_plots_interday)
```
:::

::: {.cell .markdown}
## 8. Average Distance Overview (Euclidean, Pairwise) {#average_distance_overview_2}
:::

::: {#corr_overview13 .cell .r}
```{r}
## Overview Average Euclidean Distance Table ##

generate_distance_table <- function(qcs_distances, tissue_distances) {
  # Create merged data frame
  merged_data <- data.frame(QCS = qcs_distances)
  
  # Extract tissue types
  tissue_types <- unique(tissue_distances$Type)
  
  # Iterate over each tissue type and add columns to the merged data frame
  for (i in seq_along(tissue_types)) {
    column_name <- paste("tissue_avg_distances_", i)
    tissue_distances_col <- tissue_distances %>%
      filter(Type == tissue_types[i]) %>%
      pull("Average Distance Within Tissue")
    merged_data[[column_name]] <- round(tissue_distances_col, 3)
  }
  
  # Add row names
  row.names(merged_data) <- c("No Norm", "TIC Norm", "Combat", "WaveICA", "NormAE")
  
  # Add column names
  colnames(merged_data) <- c("QCS", paste(tissue_types))
  
  return(merged_data)
}

# Example usage:
merged_data <- generate_distance_table(
  c(average_distance_ec, average_distance_ec_TIC, average_distance_ec_combat, 
    average_distance_ec_wave, average_distance_ec_norm),
  rbind(tissue_avg_distances, tissue_avg_distances_TIC, tissue_avg_distances_combat, 
        tissue_avg_distances_wave, tissue_avg_distances_norm)
)

# Load required libraries
library(kableExtra)
library(htmltools)
library(IRdisplay)

# Create HTML table
display_distance_table <- kable(merged_data, format = "html", row.names = TRUE, escape = FALSE) %>%
  kable_styling(full_width = FALSE)

# Add table name
display_distance_table <- paste("<h2 style='text-align: center;'>Average Euclidean Distance</h2>", 
                               as.character(display_distance_table))

# Display HTML table
display_html(display_distance_table)
```
:::

::: {#corr_overview14 .cell .r}
```{r}
# Overview of Pairwise Distance Table #
centroid_distances_df$Pair <- paste(centroid_distances_df$Tissue1, "-", centroid_distances_df$Tissue2)

num_pairs <- nrow(centroid_distances_df)

# Initialize an empty data frame with the correct dimensions
merged_data_pair <- matrix(NA, nrow = 5, ncol = num_pairs)

# Loop through each pair
for (i in 1:num_pairs) {
    # Extract Pair_Distance values for each method for the ith pair
    pair_distances <- c(
        round(centroid_distances_df$Pair_Distance[i], 3),
        round(centroid_distances_df_TIC$Pair_Distance[i], 3),
        round(centroid_distances_df_combat$Pair_Distance[i], 3),
        round(centroid_distances_df_wave$Pair_Distance[i], 3),
        round(centroid_distances_df_norm$Pair_Distance[i], 3)
    )
    
    # Assign the pair_distances to the corresponding column in merged_data_pair
    merged_data_pair[, i] <- pair_distances
}

# Convert the matrix to a data frame
merged_data_pair <- as.data.frame(merged_data_pair)

# Add row names
row.names(merged_data_pair) <- c("No Norm", "TIC Norm", "Combat", "WaveICA", "NormAE")

# Add column names
colnames(merged_data_pair) <- centroid_distances_df$Pair[1:num_pairs]

# Load required libraries
library(kableExtra)
library(htmltools)
library(IRdisplay)

# Create HTML table
display_pair_distance_table <- kable(merged_data_pair, format = "html", row.names = TRUE, escape = FALSE) %>%
  kable_styling(full_width = FALSE)

# Add table name
display_pair_distance_table <- paste("<h2 style='text-align: center;'>Pairwise Distance</h2>", 
                               as.character(display_pair_distance_table))

# Display HTML table
display_html(display_pair_distance_table)
```
:::

::: {#corr_overview15 .cell .r}
```{r}
## Best Correction Package ##
# ranking based on QCS interday rsd_value of (propranolol)
overview_table_pro <- data.frame(
  Row_Names = c("Intraday 1", "Intraday 2", "Intraday 3", "Interday"),
  No_norm_RSD = rsd_QCS[2],  
  TIC_norm_RSD = rsd_QCS_TIC[2],
  IS_norm_RSD = rsd_ratio[2],   
  Combat_RSD = rsd_QCS_combat[2],
  WaveICA_RSD = rsd_QCS_wave[2],
  NormAE_RSD = rsd_QCS_norm[2]
)
# Set the column names
colnames(overview_table_pro) <- c(paste("m/z value:", QCS_mz_value_2), "No Norm", "TIC Norm", "IS Norm", "Combat", "WaveICA", "NormAE")

# Convert percentage strings to numeric values
overview_table_pro[4, -1] <- as.numeric(gsub("%", "", overview_table_pro[4, -1]))
rsd_values <- overview_table_pro[4, -1] 
rsd_values <- as.numeric(rsd_values)
sorted_columns <- names(overview_table_pro)[-1][order(rsd_values)]
cat("Ranking correction based on", "\033[1mQCS Interday-only RSD value\033[0m", "from smallest to largest: \n")
print(sorted_columns)
cat("\n")


# Function to format pair distances with tissue types
format_pair_distances <- function(df) {
  apply(df, 1, function(row) paste(row["Tissue1"], "-", row["Tissue2"], ":", round(as.numeric(row["Pair_Distance"]), 2)))
}

# Function to format average distances within each tissue type
format_avg_distances <- function(df) {
  apply(df, 1, function(row) paste(row["Type"], ":", row["Average Distance Within Tissue"]))
}

# Create separate rows for each tissue value with descriptions
merged_data <- data.frame(
  Average_distances = c("QCS(euclidean)", "Tissue(intragroup)", "Tissue(intergroup)"),
  No_norm = c(
    average_distance_ec, 
    paste(format_avg_distances(tissue_avg_distances), collapse = "<br>"), 
    paste(format_pair_distances(centroid_distances_df), collapse = "<br>")
  ),
  TIC_norm = c(
    average_distance_ec_TIC, 
    paste(format_avg_distances(tissue_avg_distances_TIC), collapse = "<br>"), 
    paste(format_pair_distances(centroid_distances_df_TIC), collapse = "<br>")
  ),
  Combat_norm = c(
    average_distance_ec_combat, 
    paste(format_avg_distances(tissue_avg_distances_combat), collapse = "<br>"), 
    paste(format_pair_distances(centroid_distances_df_combat), collapse = "<br>")
  ),
  WaveICA_norm = c(
    average_distance_ec_wave, 
    paste(format_avg_distances(tissue_avg_distances_wave), collapse = "<br>"), 
    paste(format_pair_distances(centroid_distances_df_wave), collapse = "<br>")
  ),
  NormAE_norm = c(
    average_distance_ec_norm, 
    paste(format_avg_distances(tissue_avg_distances_norm), collapse = "<br>"), 
    paste(format_pair_distances(centroid_distances_df_norm), collapse = "<br>")
  )
)

# Function to extract and convert numeric values from formatted strings
extract_numeric_values <- function(row) {
  sapply(row, function(x) {
    nums <- unlist(strsplit(x, "<br>"))
    nums <- gsub("[^0-9.]", "", nums)
    mean(as.numeric(nums), na.rm = TRUE)
  })
}

# Ranking based on QCS average distance
euclidean_row <- merged_data[1, -1]  # Extract the euclidean row
euclidean_row_numeric <- as.numeric(euclidean_row)
sorted_columns_qcs <- names(merged_data)[-1][order(euclidean_row_numeric)]
cat("Ranking correction based on", "\033[1mAverage QCS Distance (Euclidean Distance)\033[0m", "from smallest to largest: \n")
print(sorted_columns_qcs)
cat("\n")


# Ranking based on Tissue average distance
intra_row <- merged_data[2, -1]  # Extract the intragroup row
inter_row <- merged_data[3, -1]  # Extract the intergroup row

intra_averages <- extract_numeric_values(intra_row)
cat("Ranking correction based on", "\033[1mAverage Tissue Intragroup Distance (Euclidean Distance)\033[0m", "from smallest to largest: \n")
sort_columns_intra <- names(merged_data)[-1][order(intra_averages)]
print(sort_columns_intra)
cat("\n")


inter_averages <- extract_numeric_values(inter_row)
cat("Ranking correction based on", "\033[1mAverage Tissue Intergroup Distance (Pairwise Distance)\033[0m", "from largest to smallest: \n")
sort_columns_inter <- names(merged_data)[-1][order(-inter_averages)]
print(sort_columns_inter)
cat("\n")


# Ranking based on tissue RSD
extract_interday_rsd <- function(rsd_results_combined, sample_set) {
  # Define a function to extract numeric values from strings with the specified pattern
  extract_numeric <- function(x) {
    as.numeric(gsub("[^0-9.]+", "", strsplit(x, "")[[1]][1]))
  }
  
  # Define a function to extract the interday RSD value for a single tissue
  extract_interday_rsd_single <- function(rsd_results, tissue_name) {
    rsd_df <- rsd_results[[tissue_name]]
    interday_rsd <- rsd_df[4, "RSD"]
    return(interday_rsd)
  }
  
  # Initialize a list to store interday RSD values for each tissue
  interday_rsd_values <- list()
  
  # Set indices for interday RSD beforehand
  interday_indices <- c("No Norm", "TIC Norm", "Combat", "WaveICA", "NormAE")
  
  # Iterate over each tissue type in the sample_set
  for (tissue_name in sample_set) {
    # Initialize a list to store interday RSD values for the current tissue across different rsd_results_combined
    interday_rsd <- list()
    
    # Iterate over each rsd_results_combined
    for (rsd_results in rsd_results_combined) {
      # Extract interday RSD values for the current tissue type from each rsd_results_combined
      interday_rsd[[length(interday_rsd) + 1]] <- extract_interday_rsd_single(rsd_results, tissue_name)
    }
    
    # Add interday RSD values for the current tissue to the main list
    names(interday_rsd) <- interday_indices  # Set names based on predefined indices
    interday_rsd_values[[tissue_name]] <- interday_rsd
  }
  
  # Define a function to sort interday RSD values for each tissue type
  sort_interday_rsd <- function(interday_rsd_values) {
    sorted_names_list <- list()
    for (tissue_name in sample_set) {
      interday_rsd <- interday_rsd_values[[tissue_name]]
      sorted_names <- lapply(interday_rsd, function(x) {
        extract_numeric(x)
      })
      sorted_indices <- names(interday_rsd)[order(unlist(sorted_names))]
      sorted_indices <- factor(sorted_indices, levels = interday_indices)
      sorted_names_list[[tissue_name]] <- sorted_indices
    }
    return(sorted_names_list)
  }
  
  # Call the sorting function
  sorted_names <- sort_interday_rsd(interday_rsd_values)
  
  # Print sorted names for each tissue type
  for (tissue_name in sample_set) {
    cat("Sorted names for", tissue_name, ":", paste(sorted_names[[tissue_name]], collapse = " "), "\n")
  }
}

cat("Ranking correction based on","\033[1mTissue Interday-only RSD\033[0m", "from smallest to largest: \n")
extract_interday_rsd(list(rsd_results_combined, rsd_results_combined_TIC, rsd_results_combined_combat, rsd_results_combined_wave, rsd_results_combined_norm), sample_set_2)
```
:::

::: {.cell .markdown}
## 5. Outputs {#outputs_2}

1.  6 Datasets as csv file (no norm, TIC norm, IS norm, Combat, WaveICA,
    NormAE) check dataset file
2.  Excel sheets (no norm, TIC norm, IS norm, Combat, WaveICA, NormAE)
    check output file
3.  Overview PDF report (one for plots and one for table)
:::

::: {#corr_excel .cell .markdown}
## Generate Excel sheets of each dataset in Intraday and Interday

You can open the excel sheets by left clicking the file in output and
select "open in new browser tab", then you can see the excel sheet is
downloaded.
:::

::: {#corr_excel2 .cell .r}
```{r}
library(openxlsx)

# Prompt the user to input the number of batches
num_batches <- as.integer(readline("Enter the number of batches in your dataset: "))

create_batch_dataset_excel <- function(data, num_batches, QCS_mz_value, file_name) {
  library(openxlsx)
  
  # Create a new Excel workbook
  wb <- createWorkbook()
  
  # Add sheets for Dataset, Intraday, and Interday
  sheet_names <- c("Dataset", paste0("Intraday ", 1:num_batches), "Interday")
  for (sheet_name in sheet_names) {
    addWorksheet(wb, sheet_name)
  }
  
  # Function to extract dataset for a specific batch
  extract_batch_dataset <- function(data, batch_number) {
    subset(data, batch == batch_number)
  }
  
  # Loop through each batch and write data to corresponding sheets
  for (i in 1:num_batches) {
    batch_dataset <- extract_batch_dataset(data, i)
    colnames(batch_dataset) <- sub("^X", "", colnames(batch_dataset))
    numeric_batch_dataset <- as.numeric(batch_dataset[, colnames(batch_dataset) == QCS_mz_value, drop = TRUE])
    
    intraday_rsd <- calculate_rsd(numeric_batch_dataset)
    batch_dataset$intraday_rsd <- intraday_rsd
    batch_dataset <- as.data.frame(batch_dataset)
    
    # Write data to Intraday sheet
    writeData(wb, sheet = paste0("Intraday ", i), x = batch_dataset, rowNames = TRUE, colNames = TRUE)
  }
  
  # Calculate Interday RSD for all data
  numeric_interday_dataset <- as.numeric(data[, colnames(data) == QCS_mz_value, drop = TRUE])
  interday_rsd <- calculate_rsd(numeric_interday_dataset)
  data$interday_rsd <- interday_rsd
  
  # Write data to Dataset and Interday sheets
  writeData(wb, sheet = "Dataset", x = data, rowNames = TRUE, colNames = TRUE)
  writeData(wb, sheet = "Interday", x = data, rowNames = TRUE, colNames = TRUE)
  
  # Save the workbook to a file, overwriting if it already exists
  file_path <- paste0("Excel/", file_name, ".xlsx")
  saveWorkbook(wb, file_path, overwrite = TRUE)
  
  return(file_path)
}

# Example usage:
if (exists("QCS_data") && length(QCS_data) > 0) {
    create_batch_dataset_excel(QCS_data, num_batches, QCS_mz_value_2, "NO_Norm_QCS_batch_dataset")
}
if (exists("QCS_data_TIC") && length(QCS_data_TIC) > 0) {
    create_batch_dataset_excel(QCS_data_TIC, num_batches, QCS_mz_value_2, "TIC_Norm_QCS_batch_dataset")
}
if (exists("ratio_data") && length(ratio_data) > 0) {
    create_batch_dataset_excel(ratio_data, num_batches, "ratio", "IS_Norm_QCS_batch_dataset")
}
if (exists("QCS_data_combat") && length(QCS_data_combat) > 0) {
    create_batch_dataset_excel(QCS_data_combat, num_batches, QCS_mz_value_2, "COMBAT_QCS_batch_dataset")
}
if (exists("QCS_data_wave") && length(QCS_data_wave) > 0) {
    create_batch_dataset_excel(QCS_data_wave, num_batches, QCS_mz_value_2, "WAVE_QCS_batch_dataset")
}
if (exists("QCS_data_norm") && length(QCS_data_norm) > 0) {
    create_batch_dataset_excel(QCS_data_norm, num_batches, QCS_mz_value_2, "NormAE_QCS_batch_dataset")
}
```
:::

::: {#corr_pdf .cell .markdown}
## Generate PDF file with all results
:::

::: {#corr_pdf2 .cell .r}
```{r}
# Function to save the HTML table to a file
save_html_table <- function(html_content, file_path) {
  # Create a full HTML document with the necessary CSS and HTML structure
  html_document <- tags$html(
    tags$head(
      tags$meta(charset = "UTF-8"),
      tags$title("RSD Table"),
      tags$link(rel = "stylesheet", href = "https://cdnjs.cloudflare.com/ajax/libs/kableExtra/1.3.4/kableExtra.min.css"),
      tags$style(
        HTML(
          ".kable-table { width: auto !important; margin-left: auto !important; margin-right: auto !important; }
           table, th, td { border: 1px solid black; border-collapse: collapse; }
           th, td { padding: 5px; text-align: left; }"
        )
      )
    ),
    tags$body(
      HTML(html_content)
    )
  )
  
  # Write the full HTML document to the specified file path
  save_html(html_document, file = file_path)
}

# Saving html tables first #

# Saving QCS RSD html tables in result folder
save_html_table(display_rsd_table_pro, "Output/QCS_rsd.html")
save_html_table(display_rsd_table_d7_pro, "Output/IS_rsd.html")

# Saving Tissue RSD html table in result folder
save_html_table(centered_combined_html, "Output/tissue_rsd.html")

# Saving Average Euclidean Distance html tables in result folder
save_html_table(display_distance_table, "Output/average_euclidean_distance.html")

# Saving Pairwise Distance html tables in result folder
save_html_table(display_pair_distance_table, "Output/pairwise_distance.html")

# Saving png plots second #

# Saving the intensity plot to a file
file_path <- "Output/intensity_plots.png"
ggsave(file_path, plot = combined_plots_intensity, width = 18, height = 25, dpi = 300)

# Saving the violin plot propranolol to a file
file_path <- "Output/violin_QCS_plots.png"
ggsave(file_path, plot = combined_plots_violin, width = 18, height = 25, dpi = 300)

# Saving the violin plot IS to a file
file_path <- "Output/violin_IS_plots.png"
ggsave(file_path, plot = combined_plots_violin_d7, width = 18, height = 25, dpi = 300)

# Saving the PCA plot to a file
file_path <- "Output/pca_plots.png"
ggsave(file_path, plot = combined_plots, width = 18, height = 25, dpi = 300)

# Saving the QCS PCA plot to a file
file_path <- "Output/QCS_pca_plots.png"
ggsave(file_path, plot = combined_plots_qcs, width = 18, height = 25, dpi = 300)

# Saving the Tissue PCA (intragroup) to a file
file_path <- "Output/intra_tissue_pca_plots.png"
ggsave(file_path, plot = tissue_plots_intra, width = 18, height = 25, dpi = 300)

# Saving the Tissue PCA (intergroup) to a file
file_path <- "Output/inter_tissue_pca_plots.png"
ggsave(file_path, plot = combined_plots_interday, width = 18, height = 25, dpi = 300)
```
:::

::: {#corr_pdf3 .cell .r}
```{r}
# Saving PNG Plots into one PDF file
library(grid)
library(png)

# List all PNG files in the result folder
png_files <- list.files("Output", pattern = "\\.png$", full.names = TRUE)

# Read each PNG file into a list of rasterGrob objects
plots <- lapply(png_files, function(file) {
  png_plot <- png::readPNG(file)
  grid::rasterGrob(png_plot, interpolate = TRUE)
})

# Create a PDF file with each plot on a separate page
pdf("Output/PNG_plots.pdf", width = 11, height = 8.5)  # Adjust width and height as needed

for (plot in plots) {
  grid.newpage()  # Start a new page
  grid.draw(plot)  # Draw the plot
}

dev.off()

cat("All plots saved to separate pages within a single PDF file in the result directory.")
```
:::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
